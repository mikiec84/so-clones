"Content"
"    private class ConnectThread extends Thread {&#xD;&#xA;	    private final BluetoothSocket mmSocket;&#xD;&#xA;	    private final BluetoothDevice mmDevice;&#xD;&#xA;	 &#xD;&#xA;	    public ConnectThread(BluetoothDevice device) {&#xD;&#xA;	        // Use a temporary object that is later assigned to mmSocket,&#xD;&#xA;	        // because mmSocket is final&#xD;&#xA;	        BluetoothSocket tmp = null;&#xD;&#xA;	        mmDevice = device;&#xD;&#xA;	 &#xD;&#xA;	        // Get a BluetoothSocket to connect with the given BluetoothDevice&#xD;&#xA;	        try {&#xD;&#xA;	            // MY_UUID is the app's UUID string, also used by the server code&#xD;&#xA;	            tmp = device.createRfcommSocketToServiceRecord(MY_UUID);&#xD;&#xA;	        } catch (IOException e) { }&#xD;&#xA;	        mmSocket = tmp;&#xD;&#xA;	    }&#xD;&#xA;	 &#xD;&#xA;	    public void run() {&#xD;&#xA;	        // Cancel discovery because it will slow down the connection&#xD;&#xA;	        mBluetoothAdapter.cancelDiscovery();&#xD;&#xA;	 &#xD;&#xA;	        try {&#xD;&#xA;	            // Connect the device through the socket. This will block&#xD;&#xA;	            // until it succeeds or throws an exception&#xD;&#xA;	            mmSocket.connect();&#xD;&#xA;	        } catch (IOException connectException) {&#xD;&#xA;	            // Unable to connect; close the socket and get out&#xD;&#xA;	            try {&#xD;&#xA;	                mmSocket.close();&#xD;&#xA;	            } catch (IOException closeException) { }&#xD;&#xA;	            return;&#xD;&#xA;	        }&#xD;&#xA;	 &#xD;&#xA;	        // Do work to manage the connection (in a separate thread)&#xD;&#xA;	        manageConnectedSocket(mmSocket);&#xD;&#xA;	    }&#xD;&#xA;	 &#xD;&#xA;	    /** Will cancel an in-progress connection, and close the socket */&#xD;&#xA;	    public void cancel() {&#xD;&#xA;	        try {&#xD;&#xA;	            mmSocket.close();&#xD;&#xA;	        } catch (IOException e) { }&#xD;&#xA;	    }&#xD;&#xA;	}"
