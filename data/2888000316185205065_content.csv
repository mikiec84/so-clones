"Content"
"        /// <summary>&#xD;&#xA;        /// Starts the given tasks and waits for them to complete. This will run, at most, the specified number of tasks in parallel.&#xD;&#xA;        /// <para>NOTE: If one of the given tasks has already been started, an exception will be thrown.</para>&#xD;&#xA;        /// </summary>&#xD;&#xA;        /// <param name=""""tasksToRun"""">The tasks to run.</param>&#xD;&#xA;        /// <param name=""""maxTasksToRunInParallel"""">The maximum number of tasks to run in parallel.</param>&#xD;&#xA;        /// <param name=""""cancellationToken"""">The cancellation token.</param>&#xD;&#xA;        public static void StartAndWaitAllThrottled(IEnumerable<Task> tasksToRun, int maxTasksToRunInParallel, CancellationToken cancellationToken = new CancellationToken())&#xD;&#xA;        {&#xD;&#xA;            StartAndWaitAllThrottled(tasksToRun, maxTasksToRunInParallel, -1, cancellationToken);&#xD;&#xA;        }&#xD;&#xA; &#xD;&#xA;        /// <summary>&#xD;&#xA;        /// Starts the given tasks and waits for them to complete. This will run, at most, the specified number of tasks in parallel.&#xD;&#xA;        /// <para>NOTE: If one of the given tasks has already been started, an exception will be thrown.</para>&#xD;&#xA;        /// </summary>&#xD;&#xA;        /// <param name=""""tasksToRun"""">The tasks to run.</param>&#xD;&#xA;        /// <param name=""""maxTasksToRunInParallel"""">The maximum number of tasks to run in parallel.</param>&#xD;&#xA;        /// <param name=""""timeoutInMilliseconds"""">The maximum milliseconds we should allow the max tasks to run in parallel before allowing another task to start. Specify -1 to wait indefinitely.</param>&#xD;&#xA;        /// <param name=""""cancellationToken"""">The cancellation token.</param>&#xD;&#xA;        public static void StartAndWaitAllThrottled(IEnumerable<Task> tasksToRun, int maxTasksToRunInParallel, int timeoutInMilliseconds, CancellationToken cancellationToken = new CancellationToken())&#xD;&#xA;        {&#xD;&#xA;            // Convert to a list of tasks so that we don&#39;t enumerate over it multiple times needlessly.&#xD;&#xA;            var tasks = tasksToRun.ToList();&#xD;&#xA; &#xD;&#xA;            using (var throttler = new SemaphoreSlim(maxTasksToRunInParallel))&#xD;&#xA;            {&#xD;&#xA;                var postTaskTasks = new List<Task>();&#xD;&#xA; &#xD;&#xA;                // Have each task notify the throttler when it completes so that it decrements the number of tasks currently running.&#xD;&#xA;                tasks.ForEach(t => postTaskTasks.Add(t.ContinueWith(tsk => throttler.Release())));&#xD;&#xA; &#xD;&#xA;                // Start running each task.&#xD;&#xA;                foreach (var task in tasks)&#xD;&#xA;                {&#xD;&#xA;                    // Increment the number of tasks currently running and wait if too many are running.&#xD;&#xA;                    throttler.Wait(timeoutInMilliseconds, cancellationToken);&#xD;&#xA; &#xD;&#xA;                    cancellationToken.ThrowIfCancellationRequested();&#xD;&#xA;                    task.Start();&#xD;&#xA;                }&#xD;&#xA; &#xD;&#xA;                // Wait for all of the provided tasks to complete.&#xD;&#xA;                // We wait on the list of """"post"""" tasks instead of the original tasks, otherwise there is a potential race condition where the throttler&#39;s using block is exited before some Tasks have had their """"post"""" action completed, which references the throttler, resulting in an exception due to accessing a disposed object.&#xD;&#xA;                Task.WaitAll(postTaskTasks.ToArray(), cancellationToken);&#xD;&#xA;            }&#xD;&#xA;        }"
