"Content"
"    CREATE FUNCTION [dbo].[DelimitedSplit8K] (@pString VARCHAR(8000), @pDelimiter CHAR(1))&#xD;&#xA;    --WARNING!!! DO NOT USE MAX DATA-TYPES HERE!  IT WILL KILL PERFORMANCE!&#xD;&#xA;    &#xD;&#xA;    RETURNS TABLE WITH SCHEMABINDING AS&#xD;&#xA;    RETURN&#xD;&#xA;    &#xD;&#xA;    /* """"Inline"""" CTE Driven """"Tally Table"""" produces values from 1 up to 10,000... enough to cover VARCHAR(8000)*/&#xD;&#xA;    &#xD;&#xA;      WITH E1(N) AS (&#xD;&#xA;                     SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL&#xD;&#xA;                     SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL&#xD;&#xA;                     SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1&#xD;&#xA;                    ),                          --10E+1 or 10 rows&#xD;&#xA;           E2(N) AS (SELECT 1 FROM E1 a, E1 b), --10E+2 or 100 rows&#xD;&#xA;           E4(N) AS (SELECT 1 FROM E2 a, E2 b), --10E+4 or 10,000 rows max&#xD;&#xA;     cteTally(N) AS (--==== This provides the """"base"""" CTE and limits the number of rows right up front&#xD;&#xA;                         -- for both a performance gain and prevention of accidental """"overruns""""&#xD;&#xA;                     SELECT TOP (ISNULL(DATALENGTH(@pString),0)) ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) FROM E4&#xD;&#xA;                    ),&#xD;&#xA;    cteStart(N1) AS (--==== This returns N+1 (starting position of each """"element"""" just once for each delimiter)&#xD;&#xA;                     SELECT 1 UNION ALL&#xD;&#xA;                     SELECT t.N+1 FROM cteTally t WHERE SUBSTRING(@pString,t.N,1) = @pDelimiter&#xD;&#xA;                    ),&#xD;&#xA;    cteLen(N1,L1) AS(--==== Return start and length (for use in substring)&#xD;&#xA;                     SELECT s.N1,&#xD;&#xA;                            ISNULL(NULLIF(CHARINDEX(@pDelimiter,@pString,s.N1),0)-s.N1,8000)&#xD;&#xA;                       FROM cteStart s&#xD;&#xA;                    )&#xD;&#xA;    --===== Do the actual split. The ISNULL/NULLIF combo handles the length for the final element when no delimiter is found.&#xD;&#xA;     SELECT ItemNumber = ROW_NUMBER() OVER(ORDER BY l.N1),&#xD;&#xA;            Item       = SUBSTRING(@pString, l.N1, l.L1)&#xD;&#xA;       FROM cteLen l&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    GO"
