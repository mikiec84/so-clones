"Content"
"    //Function to run a process as active user from windows service&#xD;&#xA;    void ImpersonateActiveUserAndRun(WCHAR* path, WCHAR* args)&#xD;&#xA;    {&#xD;&#xA;    	DWORD session_id = -1;&#xD;&#xA;    	DWORD session_count = 0;&#xD;&#xA;    &#xD;&#xA;    	WTS_SESSION_INFOA *pSession = NULL;&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    	if (WTSEnumerateSessions(WTS_CURRENT_SERVER_HANDLE, 0, 1, &pSession, &session_count))&#xD;&#xA;    	{&#xD;&#xA;    		//log success&#xD;&#xA;    	}&#xD;&#xA;    	else&#xD;&#xA;    	{&#xD;&#xA;    		//log error&#xD;&#xA;    		return;&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	for (int i = 0; i < session_count; i++)&#xD;&#xA;    	{&#xD;&#xA;    		session_id = pSession[i].SessionId;&#xD;&#xA;    &#xD;&#xA;    		WTS_CONNECTSTATE_CLASS wts_connect_state = WTSDisconnected;&#xD;&#xA;    		WTS_CONNECTSTATE_CLASS* ptr_wts_connect_state = NULL;&#xD;&#xA;    &#xD;&#xA;    		DWORD bytes_returned = 0;&#xD;&#xA;    		if (::WTSQuerySessionInformation(&#xD;&#xA;    			WTS_CURRENT_SERVER_HANDLE,&#xD;&#xA;    			session_id,&#xD;&#xA;    			WTSConnectState,&#xD;&#xA;    			reinterpret_cast<LPTSTR*>(&ptr_wts_connect_state),&#xD;&#xA;    			&bytes_returned))&#xD;&#xA;    		{&#xD;&#xA;    			wts_connect_state = *ptr_wts_connect_state;&#xD;&#xA;    			::WTSFreeMemory(ptr_wts_connect_state);&#xD;&#xA;    			if (wts_connect_state != WTSActive) continue;&#xD;&#xA;    		}&#xD;&#xA;    		else&#xD;&#xA;    		{&#xD;&#xA;    			//log error&#xD;&#xA;    			continue;&#xD;&#xA;    		}&#xD;&#xA;    &#xD;&#xA;    		HANDLE hImpersonationToken;&#xD;&#xA;    &#xD;&#xA;    		if (!WTSQueryUserToken(session_id, &hImpersonationToken))&#xD;&#xA;    		{&#xD;&#xA;    			//log error&#xD;&#xA;    			continue;&#xD;&#xA;    		}&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    		//Get real token from impersonation token&#xD;&#xA;    		DWORD neededSize1 = 0;&#xD;&#xA;    		HANDLE *realToken = new HANDLE;&#xD;&#xA;    		if (GetTokenInformation(hImpersonationToken, (::TOKEN_INFORMATION_CLASS) TokenLinkedToken, realToken, sizeof(HANDLE), &neededSize1))&#xD;&#xA;    		{&#xD;&#xA;    			CloseHandle(hImpersonationToken);&#xD;&#xA;    			hImpersonationToken = *realToken;&#xD;&#xA;    		}&#xD;&#xA;    		else&#xD;&#xA;    		{&#xD;&#xA;    			//log error&#xD;&#xA;    			continue;&#xD;&#xA;    		}&#xD;&#xA;    		&#xD;&#xA;    &#xD;&#xA;    		HANDLE hUserToken;&#xD;&#xA;    &#xD;&#xA;    		if (!DuplicateTokenEx(hImpersonationToken,&#xD;&#xA;    			//0,&#xD;&#xA;    			//MAXIMUM_ALLOWED,&#xD;&#xA;    			TOKEN_ASSIGN_PRIMARY | TOKEN_ALL_ACCESS | MAXIMUM_ALLOWED,&#xD;&#xA;    			NULL,&#xD;&#xA;    			SecurityImpersonation,&#xD;&#xA;    			TokenPrimary,&#xD;&#xA;    			&hUserToken))&#xD;&#xA;    		{&#xD;&#xA;    			//log error&#xD;&#xA;    			continue;&#xD;&#xA;    		}&#xD;&#xA;    &#xD;&#xA;    		// Get user name of this process&#xD;&#xA;    		//LPTSTR pUserName = NULL;&#xD;&#xA;    		WCHAR* pUserName;&#xD;&#xA;    		DWORD user_name_len = 0;&#xD;&#xA;    &#xD;&#xA;    		if (WTSQuerySessionInformationW(WTS_CURRENT_SERVER_HANDLE, session_id, WTSUserName, &pUserName, &user_name_len))&#xD;&#xA;    		{&#xD;&#xA;    			//log username contained in pUserName WCHAR string&#xD;&#xA;    		}&#xD;&#xA;    &#xD;&#xA;    		//Free memory                         &#xD;&#xA;    		if (pUserName) WTSFreeMemory(pUserName);&#xD;&#xA;    &#xD;&#xA;    		ImpersonateLoggedOnUser(hUserToken);&#xD;&#xA;    		&#xD;&#xA;    		STARTUPINFOW StartupInfo;&#xD;&#xA;    		GetStartupInfoW(&StartupInfo);&#xD;&#xA;    		StartupInfo.cb = sizeof(STARTUPINFOW);&#xD;&#xA;    		//StartupInfo.lpDesktop = """"winsta0\\default"""";&#xD;&#xA;    		&#xD;&#xA;    		PROCESS_INFORMATION processInfo;&#xD;&#xA;    &#xD;&#xA;    		SECURITY_ATTRIBUTES Security1;&#xD;&#xA;    		Security1.nLength = sizeof SECURITY_ATTRIBUTES;&#xD;&#xA;    &#xD;&#xA;    		SECURITY_ATTRIBUTES Security2;&#xD;&#xA;    		Security2.nLength = sizeof SECURITY_ATTRIBUTES;&#xD;&#xA;    &#xD;&#xA;    		void* lpEnvironment = NULL;&#xD;&#xA;    &#xD;&#xA;    		// Get all necessary environment variables of logged in user&#xD;&#xA;    		// to pass them to the new process&#xD;&#xA;    		BOOL resultEnv = CreateEnvironmentBlock(&lpEnvironment, hUserToken, FALSE);&#xD;&#xA;    		if (!resultEnv)&#xD;&#xA;    		{&#xD;&#xA;    			//log error&#xD;&#xA;    			continue;&#xD;&#xA;    		}&#xD;&#xA;    &#xD;&#xA;    		WCHAR PP[1024]; //path and parameters&#xD;&#xA;    		ZeroMemory(PP, 1024 * sizeof WCHAR);&#xD;&#xA;    		wcscpy(PP, path);&#xD;&#xA;    		wcscat(PP, L"""" """");&#xD;&#xA;    		wcscat(PP, args);&#xD;&#xA;    &#xD;&#xA;    		// Start the process on behalf of the current user &#xD;&#xA;    		BOOL result = CreateProcessAsUserW(hUserToken, &#xD;&#xA;    			NULL,&#xD;&#xA;    			PP,&#xD;&#xA;    			//&Security1,&#xD;&#xA;    			//&Security2,&#xD;&#xA;    			NULL,&#xD;&#xA;    			NULL,&#xD;&#xA;    			FALSE, &#xD;&#xA;    			NORMAL_PRIORITY_CLASS | CREATE_NEW_CONSOLE,&#xD;&#xA;    			//lpEnvironment,&#xD;&#xA;    			NULL,&#xD;&#xA;    			//""""C:\\ProgramData\\some_dir"""",&#xD;&#xA;    			NULL,&#xD;&#xA;    			&StartupInfo,&#xD;&#xA;    			&processInfo);&#xD;&#xA;    &#xD;&#xA;    		if (!result)&#xD;&#xA;    		{&#xD;&#xA;    			//log error&#xD;&#xA;    		}&#xD;&#xA;    		else&#xD;&#xA;    		{&#xD;&#xA;    			//log success&#xD;&#xA;    		}&#xD;&#xA;    &#xD;&#xA;    		DestroyEnvironmentBlock(lpEnvironment);&#xD;&#xA;    &#xD;&#xA;    		CloseHandle(hImpersonationToken);&#xD;&#xA;    		CloseHandle(hUserToken);&#xD;&#xA;    		CloseHandle(realToken);&#xD;&#xA;    &#xD;&#xA;    		RevertToSelf();&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	WTSFreeMemory(pSession);&#xD;&#xA;    }"
