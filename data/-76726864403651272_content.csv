"Content"
"    import android.content.Context;&#xD;&#xA;    import android.graphics.Matrix;&#xD;&#xA;    import android.graphics.PointF;&#xD;&#xA;    import android.graphics.drawable.Drawable;&#xD;&#xA;    import android.util.AttributeSet;&#xD;&#xA;    import android.util.Log;&#xD;&#xA;    import android.view.MotionEvent;&#xD;&#xA;    import android.view.ScaleGestureDetector;&#xD;&#xA;    import android.view.View;&#xD;&#xA;    import android.widget.ImageView;&#xD;&#xA;    &#xD;&#xA;    public class TouchImageView extends ImageView {&#xD;&#xA;	Matrix matrix;&#xD;&#xA;	// We can be in one of these 3 states&#xD;&#xA;	static final int NONE = 0;&#xD;&#xA;	static final int DRAG = 1;&#xD;&#xA;	static final int ZOOM = 2;&#xD;&#xA;	int mode = NONE;&#xD;&#xA;	// Remember some things for zooming&#xD;&#xA;	PointF last = new PointF();&#xD;&#xA;	PointF start = new PointF();&#xD;&#xA;	float minScale = 1f;&#xD;&#xA;	float maxScale = 3f;&#xD;&#xA;	float[] m;&#xD;&#xA;	int viewWidth, viewHeight;&#xD;&#xA;	static final int CLICK = 3;&#xD;&#xA;	float saveScale = 1f;&#xD;&#xA;	protected float origWidth, origHeight;&#xD;&#xA;	int oldMeasuredWidth, oldMeasuredHeight;&#xD;&#xA;	ScaleGestureDetector mScaleDetector;&#xD;&#xA;	Context context;&#xD;&#xA;	public TouchImageView(Context context) {&#xD;&#xA;		super(context);&#xD;&#xA;		sharedConstructing(context);&#xD;&#xA;	}&#xD;&#xA;	public TouchImageView(Context context, AttributeSet attrs) {&#xD;&#xA;		super(context, attrs);&#xD;&#xA;		sharedConstructing(context);&#xD;&#xA;	}&#xD;&#xA;	private void sharedConstructing(Context context) {&#xD;&#xA;		super.setClickable(true);&#xD;&#xA;		this.context = context;&#xD;&#xA;		mScaleDetector = new ScaleGestureDetector(context, new ScaleListener());&#xD;&#xA;		matrix = new Matrix();&#xD;&#xA;		m = new float[9];&#xD;&#xA;		setImageMatrix(matrix);&#xD;&#xA;		setScaleType(ScaleType.MATRIX);&#xD;&#xA;		setOnTouchListener(new OnTouchListener() {&#xD;&#xA;			@Override&#xD;&#xA;			public boolean onTouch(View v, MotionEvent event) {&#xD;&#xA;				mScaleDetector.onTouchEvent(event);&#xD;&#xA;				PointF curr = new PointF(event.getX(), event.getY());&#xD;&#xA;				switch (event.getAction()) {&#xD;&#xA;				case MotionEvent.ACTION_DOWN:&#xD;&#xA;					last.set(curr);&#xD;&#xA;					start.set(last);&#xD;&#xA;					mode = DRAG;&#xD;&#xA;					break;&#xD;&#xA;				case MotionEvent.ACTION_MOVE:&#xD;&#xA;					if (mode == DRAG) {&#xD;&#xA;						float deltaX = curr.x - last.x;&#xD;&#xA;						float deltaY = curr.y - last.y;&#xD;&#xA;						float fixTransX = getFixDragTrans(deltaX, viewWidth,&#xD;&#xA;								origWidth * saveScale);&#xD;&#xA;						float fixTransY = getFixDragTrans(deltaY, viewHeight,&#xD;&#xA;								origHeight * saveScale);&#xD;&#xA;						matrix.postTranslate(fixTransX, fixTransY);&#xD;&#xA;						fixTrans();&#xD;&#xA;						last.set(curr.x, curr.y);&#xD;&#xA;					}&#xD;&#xA;					break;&#xD;&#xA;				case MotionEvent.ACTION_UP:&#xD;&#xA;					mode = NONE;&#xD;&#xA;					int xDiff = (int) Math.abs(curr.x - start.x);&#xD;&#xA;					int yDiff = (int) Math.abs(curr.y - start.y);&#xD;&#xA;					if (xDiff < CLICK && yDiff < CLICK)&#xD;&#xA;						performClick();&#xD;&#xA;					break;&#xD;&#xA;				case MotionEvent.ACTION_POINTER_UP:&#xD;&#xA;					mode = NONE;&#xD;&#xA;					break;&#xD;&#xA;				}&#xD;&#xA;				setImageMatrix(matrix);&#xD;&#xA;				invalidate();&#xD;&#xA;				return true; // indicate event was handled&#xD;&#xA;			}&#xD;&#xA;		});&#xD;&#xA;	}&#xD;&#xA;	public void setMaxZoom(float x) {&#xD;&#xA;		maxScale = x;&#xD;&#xA;	}&#xD;&#xA;	private class ScaleListener extends&#xD;&#xA;			ScaleGestureDetector.SimpleOnScaleGestureListener {&#xD;&#xA;		@Override&#xD;&#xA;		public boolean onScaleBegin(ScaleGestureDetector detector) {&#xD;&#xA;			mode = ZOOM;&#xD;&#xA;			return true;&#xD;&#xA;		}&#xD;&#xA;		@Override&#xD;&#xA;		public boolean onScale(ScaleGestureDetector detector) {&#xD;&#xA;			float mScaleFactor = detector.getScaleFactor();&#xD;&#xA;			float origScale = saveScale;&#xD;&#xA;			saveScale *= mScaleFactor;&#xD;&#xA;			if (saveScale > maxScale) {&#xD;&#xA;				saveScale = maxScale;&#xD;&#xA;				mScaleFactor = maxScale / origScale;&#xD;&#xA;			} else if (saveScale < minScale) {&#xD;&#xA;				saveScale = minScale;&#xD;&#xA;				mScaleFactor = minScale / origScale;&#xD;&#xA;			}&#xD;&#xA;			if (origWidth * saveScale <= viewWidth&#xD;&#xA;					|| origHeight * saveScale <= viewHeight)&#xD;&#xA;				matrix.postScale(mScaleFactor, mScaleFactor, viewWidth / 2,&#xD;&#xA;						viewHeight / 2);&#xD;&#xA;			else&#xD;&#xA;				matrix.postScale(mScaleFactor, mScaleFactor,&#xD;&#xA;						detector.getFocusX(), detector.getFocusY());&#xD;&#xA;			fixTrans();&#xD;&#xA;			return true;&#xD;&#xA;		}&#xD;&#xA;	}&#xD;&#xA;	void fixTrans() {&#xD;&#xA;		matrix.getValues(m);&#xD;&#xA;		float transX = m[Matrix.MTRANS_X];&#xD;&#xA;		float transY = m[Matrix.MTRANS_Y];&#xD;&#xA;		float fixTransX = getFixTrans(transX, viewWidth, origWidth * saveScale);&#xD;&#xA;		float fixTransY = getFixTrans(transY, viewHeight, origHeight&#xD;&#xA;				* saveScale);&#xD;&#xA;		if (fixTransX != 0 || fixTransY != 0)&#xD;&#xA;			matrix.postTranslate(fixTransX, fixTransY);&#xD;&#xA;	}&#xD;&#xA;	float getFixTrans(float trans, float viewSize, float contentSize) {&#xD;&#xA;		float minTrans, maxTrans;&#xD;&#xA;		if (contentSize <= viewSize) {&#xD;&#xA;			minTrans = 0;&#xD;&#xA;			maxTrans = viewSize - contentSize;&#xD;&#xA;		} else {&#xD;&#xA;			minTrans = viewSize - contentSize;&#xD;&#xA;			maxTrans = 0;&#xD;&#xA;		}&#xD;&#xA;		if (trans < minTrans)&#xD;&#xA;			return -trans + minTrans;&#xD;&#xA;		if (trans > maxTrans)&#xD;&#xA;			return -trans + maxTrans;&#xD;&#xA;		return 0;&#xD;&#xA;	}&#xD;&#xA;	float getFixDragTrans(float delta, float viewSize, float contentSize) {&#xD;&#xA;		if (contentSize <= viewSize) {&#xD;&#xA;			return 0;&#xD;&#xA;		}&#xD;&#xA;		return delta;&#xD;&#xA;	}&#xD;&#xA;	@Override&#xD;&#xA;	protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {&#xD;&#xA;		super.onMeasure(widthMeasureSpec, heightMeasureSpec);&#xD;&#xA;		viewWidth = MeasureSpec.getSize(widthMeasureSpec);&#xD;&#xA;		viewHeight = MeasureSpec.getSize(heightMeasureSpec);&#xD;&#xA;		//&#xD;&#xA;		// Rescales image on rotation&#xD;&#xA;		//&#xD;&#xA;		if (oldMeasuredHeight == viewWidth && oldMeasuredHeight == viewHeight&#xD;&#xA;				|| viewWidth == 0 || viewHeight == 0)&#xD;&#xA;			return;&#xD;&#xA;		oldMeasuredHeight = viewHeight;&#xD;&#xA;		oldMeasuredWidth = viewWidth;&#xD;&#xA;		if (saveScale == 1) {&#xD;&#xA;			// Fit to screen.&#xD;&#xA;			float scale;&#xD;&#xA;			Drawable drawable = getDrawable();&#xD;&#xA;			if (drawable == null || drawable.getIntrinsicWidth() == 0&#xD;&#xA;					|| drawable.getIntrinsicHeight() == 0)&#xD;&#xA;				return;&#xD;&#xA;			int bmWidth = drawable.getIntrinsicWidth();&#xD;&#xA;			int bmHeight = drawable.getIntrinsicHeight();&#xD;&#xA;			Log.d(""""bmSize"""", """"bmWidth: """" + bmWidth + """" bmHeight : """" + bmHeight);&#xD;&#xA;			float scaleX = (float) viewWidth / (float) bmWidth;&#xD;&#xA;			float scaleY = (float) viewHeight / (float) bmHeight;&#xD;&#xA;			scale = Math.min(scaleX, scaleY);&#xD;&#xA;			matrix.setScale(scale, scale);&#xD;&#xA;			// Center the image&#xD;&#xA;			float redundantYSpace = (float) viewHeight&#xD;&#xA;					- (scale * (float) bmHeight);&#xD;&#xA;			float redundantXSpace = (float) viewWidth&#xD;&#xA;					- (scale * (float) bmWidth);&#xD;&#xA;			redundantYSpace /= (float) 2;&#xD;&#xA;			redundantXSpace /= (float) 2;&#xD;&#xA;			matrix.postTranslate(redundantXSpace, redundantYSpace);&#xD;&#xA;			origWidth = viewWidth - 2 * redundantXSpace;&#xD;&#xA;			origHeight = viewHeight - 2 * redundantYSpace;&#xD;&#xA;			setImageMatrix(matrix);&#xD;&#xA;		}&#xD;&#xA;		fixTrans();&#xD;&#xA;	}&#xD;&#xA;    }"
