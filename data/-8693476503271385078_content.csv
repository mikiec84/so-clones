"Content"
"    using System;&#xD;&#xA;    using System.Diagnostics;&#xD;&#xA;    using System.Text;&#xD;&#xA;    using System.Threading;&#xD;&#xA;    using System.Threading.Tasks;&#xD;&#xA;    &#xD;&#xA;    public class ConsoleAppManager&#xD;&#xA;    {&#xD;&#xA;        private readonly string appName;&#xD;&#xA;        private readonly Process process = new Process();&#xD;&#xA;        private readonly object theLock = new object();&#xD;&#xA;        private SynchronizationContext context;&#xD;&#xA;        private string pendingWriteData;&#xD;&#xA;    &#xD;&#xA;        public ConsoleAppManager(string appName)&#xD;&#xA;        {&#xD;&#xA;            this.appName = appName;&#xD;&#xA;    &#xD;&#xA;            this.process.StartInfo.FileName = this.appName;&#xD;&#xA;            this.process.StartInfo.RedirectStandardError = true;&#xD;&#xA;            this.process.StartInfo.StandardErrorEncoding = Encoding.UTF8;&#xD;&#xA;    &#xD;&#xA;            this.process.StartInfo.RedirectStandardInput = true;&#xD;&#xA;            this.process.StartInfo.RedirectStandardOutput = true;&#xD;&#xA;            this.process.EnableRaisingEvents = true;&#xD;&#xA;            this.process.StartInfo.CreateNoWindow = true;&#xD;&#xA;    &#xD;&#xA;            this.process.StartInfo.UseShellExecute = false;&#xD;&#xA;    &#xD;&#xA;            this.process.StartInfo.StandardOutputEncoding = Encoding.UTF8;&#xD;&#xA;    &#xD;&#xA;            this.process.Exited += this.ProcessOnExited;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        public event EventHandler<string> ErrorTextReceived;&#xD;&#xA;        public event EventHandler ProcessExited;&#xD;&#xA;        public event EventHandler<string> StandartTextReceived;&#xD;&#xA;    &#xD;&#xA;        public int ExitCode&#xD;&#xA;        {&#xD;&#xA;            get { return this.process.ExitCode; }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        public bool Running&#xD;&#xA;        {&#xD;&#xA;            get; private set;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        public void ExecuteAsync(params string[] args)&#xD;&#xA;        {&#xD;&#xA;            if (this.Running)&#xD;&#xA;            {&#xD;&#xA;                throw new InvalidOperationException(&#xD;&#xA;                    """"Process is still Running. Please wait for the process to complete."""");&#xD;&#xA;            }&#xD;&#xA;    &#xD;&#xA;            string arguments = string.Join("""" """", args);&#xD;&#xA;    &#xD;&#xA;            this.process.StartInfo.Arguments = arguments;&#xD;&#xA;    &#xD;&#xA;            this.context = SynchronizationContext.Current;&#xD;&#xA;    &#xD;&#xA;            this.process.Start();&#xD;&#xA;            this.Running = true;&#xD;&#xA;    &#xD;&#xA;            new Task(this.ReadOutputAsync).Start();&#xD;&#xA;            new Task(this.WriteInputTask).Start();&#xD;&#xA;            new Task(this.ReadOutputErrorAsync).Start();&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        public void Write(string data)&#xD;&#xA;        {&#xD;&#xA;            if (data == null)&#xD;&#xA;            {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;    &#xD;&#xA;            lock (this.theLock)&#xD;&#xA;            {&#xD;&#xA;                this.pendingWriteData = data;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        public void WriteLine(string data)&#xD;&#xA;        {&#xD;&#xA;            this.Write(data + Environment.NewLine);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        protected virtual void OnErrorTextReceived(string e)&#xD;&#xA;        {&#xD;&#xA;            EventHandler<string> handler = this.ErrorTextReceived;&#xD;&#xA;    &#xD;&#xA;            if (handler != null)&#xD;&#xA;            {&#xD;&#xA;                if (this.context != null)&#xD;&#xA;                {&#xD;&#xA;                    this.context.Post(delegate { handler(this, e); }, null);&#xD;&#xA;                }&#xD;&#xA;                else&#xD;&#xA;                {&#xD;&#xA;                    handler(this, e);&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        protected virtual void OnProcessExited()&#xD;&#xA;        {&#xD;&#xA;            EventHandler handler = this.ProcessExited;&#xD;&#xA;            if (handler != null)&#xD;&#xA;            {&#xD;&#xA;                handler(this, EventArgs.Empty);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        protected virtual void OnStandartTextReceived(string e)&#xD;&#xA;        {&#xD;&#xA;            EventHandler<string> handler = this.StandartTextReceived;&#xD;&#xA;    &#xD;&#xA;            if (handler != null)&#xD;&#xA;            {&#xD;&#xA;                if (this.context != null)&#xD;&#xA;                {&#xD;&#xA;                    this.context.Post(delegate { handler(this, e); }, null);&#xD;&#xA;                }&#xD;&#xA;                else&#xD;&#xA;                {&#xD;&#xA;                    handler(this, e);&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        private void ProcessOnExited(object sender, EventArgs eventArgs)&#xD;&#xA;        {&#xD;&#xA;            this.OnProcessExited();&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        private async void ReadOutputAsync()&#xD;&#xA;        {&#xD;&#xA;            var standart = new StringBuilder();&#xD;&#xA;            var buff = new char[1024];&#xD;&#xA;            int length;&#xD;&#xA;    &#xD;&#xA;            while (this.process.HasExited == false)&#xD;&#xA;            {&#xD;&#xA;                standart.Clear();&#xD;&#xA;    &#xD;&#xA;                length = await this.process.StandardOutput.ReadAsync(buff, 0, buff.Length);&#xD;&#xA;                standart.Append(buff.SubArray(0, length));&#xD;&#xA;                this.OnStandartTextReceived(standart.ToString());&#xD;&#xA;                Thread.Sleep(1);&#xD;&#xA;            }&#xD;&#xA;    &#xD;&#xA;            this.Running = false;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        private async void ReadOutputErrorAsync()&#xD;&#xA;        {&#xD;&#xA;            var sb = new StringBuilder();&#xD;&#xA;    &#xD;&#xA;            do&#xD;&#xA;            {&#xD;&#xA;                sb.Clear();&#xD;&#xA;                var buff = new char[1024];&#xD;&#xA;                int length = await this.process.StandardError.ReadAsync(buff, 0, buff.Length);&#xD;&#xA;                sb.Append(buff.SubArray(0, length));&#xD;&#xA;                this.OnErrorTextReceived(sb.ToString());&#xD;&#xA;                Thread.Sleep(1);&#xD;&#xA;            }&#xD;&#xA;            while (this.process.HasExited == false);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        private async void WriteInputTask()&#xD;&#xA;        {&#xD;&#xA;            while (this.process.HasExited == false)&#xD;&#xA;            {&#xD;&#xA;                Thread.Sleep(1);&#xD;&#xA;    &#xD;&#xA;                if (this.pendingWriteData != null)&#xD;&#xA;                {&#xD;&#xA;                    await this.process.StandardInput.WriteLineAsync(this.pendingWriteData);&#xD;&#xA;                    await this.process.StandardInput.FlushAsync();&#xD;&#xA;    &#xD;&#xA;                    lock (this.theLock)&#xD;&#xA;                    {&#xD;&#xA;                        this.pendingWriteData = null;&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }"
