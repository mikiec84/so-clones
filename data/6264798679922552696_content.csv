"Content"
"     - (NSData *)AES256DecryptWithKey:(NSString *)key&#xD;&#xA;    {&#xD;&#xA;      // 'key' should be 32 bytes for AES256, will be null-padded otherwise&#xD;&#xA;      char keyPtr[kCCKeySizeAES256+1]; // room for terminator (unused)&#xD;&#xA;      bzero( keyPtr, sizeof( keyPtr ) ); // fill with zeroes (for padding)&#xD;&#xA;      &#xD;&#xA;      // fetch key data&#xD;&#xA;      [key getCString:keyPtr maxLength:sizeof( keyPtr ) encoding:NSUTF8StringEncoding];&#xD;&#xA;      &#xD;&#xA;      NSUInteger dataLength = [self length];&#xD;&#xA;      &#xD;&#xA;      //See the doc: For block ciphers, the output size will always be less than or &#xD;&#xA;      //equal to the input size plus the size of one block.&#xD;&#xA;      //That's why we need to add the size of one block here&#xD;&#xA;      size_t bufferSize = dataLength + kCCBlockSizeAES128;&#xD;&#xA;      void *buffer = malloc( bufferSize );&#xD;&#xA;      &#xD;&#xA;      size_t numBytesDecrypted = 0;&#xD;&#xA;      CCCryptorStatus cryptStatus = CCCrypt( kCCDecrypt, kCCAlgorithmAES128, kCCOptionPKCS7Padding,&#xD;&#xA;                                            keyPtr, kCCKeySizeAES256,&#xD;&#xA;                                            NULL /* initialization vector (optional) */,&#xD;&#xA;                                            [self bytes], dataLength, /* input */&#xD;&#xA;                                            buffer, bufferSize, /* output */&#xD;&#xA;                                            &numBytesDecrypted );&#xD;&#xA;      &#xD;&#xA;      if( cryptStatus == kCCSuccess )&#xD;&#xA;      {&#xD;&#xA;        //the returned NSData takes ownership of the buffer and will free it on deallocation&#xD;&#xA;        return [NSData dataWithBytesNoCopy:buffer length:numBytesDecrypted];&#xD;&#xA;      }&#xD;&#xA;      &#xD;&#xA;      free( buffer ); //free the buffer&#xD;&#xA;      return nil;&#xD;&#xA;    }"
