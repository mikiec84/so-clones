"Content"
"		CREATE FUNCTION dbo.DelimitedSplit8K&#xD;&#xA;		--===== Define I/O parameters&#xD;&#xA;			(@pString VARCHAR(8000), @pDelimiter CHAR(1))&#xD;&#xA;		RETURNS TABLE WITH SCHEMABINDING AS&#xD;&#xA;		RETURN&#xD;&#xA;		--===== """"Inline"""" CTE Driven """"Tally Table"""" produces values from 0 up to 10,000...&#xD;&#xA;			-- enough to cover VARCHAR(8000)&#xD;&#xA;		WITH E1(N) AS (&#xD;&#xA;						SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL &#xD;&#xA;						SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL &#xD;&#xA;						SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1&#xD;&#xA;					),                          --10E+1 or 10 rows&#xD;&#xA;			E2(N) AS (SELECT 1 FROM E1 a, E1 b), --10E+2 or 100 rows&#xD;&#xA;			E4(N) AS (SELECT 1 FROM E2 a, E2 b), --10E+4 or 10,000 rows max&#xD;&#xA;		cteTally(N) AS (--==== This provides the """"zero base"""" and limits the number of rows right up front&#xD;&#xA;							-- for both a performance gain and prevention of accidental """"overruns""""&#xD;&#xA;						SELECT 0 UNION ALL&#xD;&#xA;						SELECT TOP (DATALENGTH(ISNULL(@pString,1))) ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) FROM E4&#xD;&#xA;					),&#xD;&#xA;		cteStart(N1) AS (--==== This returns N+1 (starting position of each """"element"""" just once for each delimiter)&#xD;&#xA;						SELECT t.N+1&#xD;&#xA;						FROM cteTally t&#xD;&#xA;						WHERE (SUBSTRING(@pString,t.N,1) = @pDelimiter OR t.N = 0) &#xD;&#xA;					)&#xD;&#xA;		--===== Do the actual split. The ISNULL/NULLIF combo handles the length for the final element when no delimiter is found.&#xD;&#xA;		SELECT ItemNumber = ROW_NUMBER() OVER(ORDER BY s.N1),&#xD;&#xA;			Item = SUBSTRING(@pString,s.N1,ISNULL(NULLIF(CHARINDEX(@pDelimiter,@pString,s.N1),0)-s.N1,8000))&#xD;&#xA;		FROM cteStart s;&#xD;&#xA;				"
