"Content"
"    // This function takes arguments for 2 connection strings and commands to create a transaction  &#xD;&#xA;    // involving two SQL Servers. It returns a value > 0 if the transaction is committed, 0 if the  &#xD;&#xA;    // transaction is rolled back. To test this code, you can connect to two different databases  &#xD;&#xA;    // on the same server by altering the connection string, or to another 3rd party RDBMS by  &#xD;&#xA;    // altering the code in the connection2 code block. &#xD;&#xA;    static public int CreateTransactionScope(&#xD;&#xA;        string connectString1, string connectString2,&#xD;&#xA;        string commandText1, string commandText2)&#xD;&#xA;    {&#xD;&#xA;        // Initialize the return value to zero and create a StringWriter to display results. &#xD;&#xA;        int returnValue = 0;&#xD;&#xA;        System.IO.StringWriter writer = new System.IO.StringWriter();&#xD;&#xA;    &#xD;&#xA;        try&#xD;&#xA;        {&#xD;&#xA;            // Create the TransactionScope to execute the commands, guaranteeing &#xD;&#xA;            // that both commands can commit or roll back as a single unit of work. &#xD;&#xA;            using (TransactionScope scope = new TransactionScope())&#xD;&#xA;            {&#xD;&#xA;                using (SqlConnection connection1 = new SqlConnection(connectString1))&#xD;&#xA;                {&#xD;&#xA;                    // Opening the connection automatically enlists it in the  &#xD;&#xA;                    // TransactionScope as a lightweight transaction.&#xD;&#xA;                    connection1.Open();&#xD;&#xA;    &#xD;&#xA;                    // Create the SqlCommand object and execute the first command.&#xD;&#xA;                    SqlCommand command1 = new SqlCommand(commandText1, connection1);&#xD;&#xA;                    returnValue = command1.ExecuteNonQuery();&#xD;&#xA;                    writer.WriteLine(""""Rows to be affected by command1: {0}"""", returnValue);&#xD;&#xA;    &#xD;&#xA;                    // If you get here, this means that command1 succeeded. By nesting &#xD;&#xA;                    // the using block for connection2 inside that of connection1, you &#xD;&#xA;                    // conserve server and network resources as connection2 is opened &#xD;&#xA;                    // only when there is a chance that the transaction can commit.    &#xD;&#xA;                    using (SqlConnection connection2 = new SqlConnection(connectString2))&#xD;&#xA;                    {&#xD;&#xA;                        // The transaction is escalated to a full distributed &#xD;&#xA;                        // transaction when connection2 is opened.&#xD;&#xA;                        connection2.Open();&#xD;&#xA;    &#xD;&#xA;                        // Execute the second command in the second database.&#xD;&#xA;                        returnValue = 0;&#xD;&#xA;                        SqlCommand command2 = new SqlCommand(commandText2, connection2);&#xD;&#xA;                        returnValue = command2.ExecuteNonQuery();&#xD;&#xA;                        writer.WriteLine(""""Rows to be affected by command2: {0}"""", returnValue);&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;    &#xD;&#xA;                // The Complete method commits the transaction. If an exception has been thrown, &#xD;&#xA;                // Complete is not  called and the transaction is rolled back.&#xD;&#xA;                scope.Complete();&#xD;&#xA;    &#xD;&#xA;            }&#xD;&#xA;    &#xD;&#xA;        }&#xD;&#xA;        catch (TransactionAbortedException ex)&#xD;&#xA;        {&#xD;&#xA;            writer.WriteLine(""""TransactionAbortedException Message: {0}"""", ex.Message);&#xD;&#xA;        }&#xD;&#xA;        catch (ApplicationException ex)&#xD;&#xA;        {&#xD;&#xA;            writer.WriteLine(""""ApplicationException Message: {0}"""", ex.Message);&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        // Display messages.&#xD;&#xA;        Console.WriteLine(writer.ToString());&#xD;&#xA;    &#xD;&#xA;        return returnValue;&#xD;&#xA;    }"
