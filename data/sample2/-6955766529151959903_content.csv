"Content"
"	private async Task GetPreviewFrameAsSoftwareBitmapAsync()&#xD;&#xA;	{&#xD;&#xA;		// Get information about the preview&#xD;&#xA;		var previewProperties = _mediaCapture.VideoDeviceController.GetMediaStreamProperties(MediaStreamType.VideoPreview) as VideoEncodingProperties;&#xD;&#xA;		// Create the video frame to request a SoftwareBitmap preview frame&#xD;&#xA;		var videoFrame = new VideoFrame(BitmapPixelFormat.Bgra8, (int)previewProperties.Width, (int)previewProperties.Height);&#xD;&#xA;		// Capture the preview frame&#xD;&#xA;		using (var currentFrame = await _mediaCapture.GetPreviewFrameAsync(videoFrame))&#xD;&#xA;		{&#xD;&#xA;			// Collect the resulting frame&#xD;&#xA;			SoftwareBitmap previewFrame = currentFrame.SoftwareBitmap;&#xD;&#xA;			// Add a simple green filter effect to the SoftwareBitmap&#xD;&#xA;            EditPixels(previewFrame);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    private unsafe void EditPixels(SoftwareBitmap bitmap)&#xD;&#xA;	{&#xD;&#xA;		// Effect is hard-coded to operate on BGRA8 format only&#xD;&#xA;		if (bitmap.BitmapPixelFormat == BitmapPixelFormat.Bgra8)&#xD;&#xA;		{&#xD;&#xA;			// In BGRA8 format, each pixel is defined by 4 bytes&#xD;&#xA;			const int BYTES_PER_PIXEL = 4;&#xD;&#xA;			using (var buffer = bitmap.LockBuffer(BitmapBufferAccessMode.ReadWrite))&#xD;&#xA;			using (var reference = buffer.CreateReference())&#xD;&#xA;			{&#xD;&#xA;				// Get a pointer to the pixel buffer&#xD;&#xA;				byte* data;&#xD;&#xA;				uint capacity;&#xD;&#xA;				((IMemoryBufferByteAccess)reference).GetBuffer(out data, out capacity);&#xD;&#xA;				// Get information about the BitmapBuffer&#xD;&#xA;				var desc = buffer.GetPlaneDescription(0);&#xD;&#xA;				// Iterate over all pixels&#xD;&#xA;				for (uint row = 0; row < desc.Height; row++)&#xD;&#xA;				{&#xD;&#xA;					for (uint col = 0; col < desc.Width; col++)&#xD;&#xA;					{&#xD;&#xA;						// Index of the current pixel in the buffer (defined by the next 4 bytes, BGRA8)&#xD;&#xA;						var currPixel = desc.StartIndex + desc.Stride * row + BYTES_PER_PIXEL * col;&#xD;&#xA;						// Read the current pixel information into b,g,r channels (leave out alpha channel)&#xD;&#xA;						var b = data[currPixel + 0]; // Blue&#xD;&#xA;						var g = data[currPixel + 1]; // Green&#xD;&#xA;						var r = data[currPixel + 2]; // Red&#xD;&#xA;						// Boost the green channel, leave the other two untouched&#xD;&#xA;						data[currPixel + 0] = b;&#xD;&#xA;						data[currPixel + 1] = (byte)Math.Min(g + 80, 255);&#xD;&#xA;						data[currPixel + 2] = r;&#xD;&#xA;					}&#xD;&#xA;				}&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;	}"
