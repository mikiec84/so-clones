"Content"
"        public class ImageLoader {&#xD;&#xA;        &#xD;&#xA;        	MemoryCache memoryCache = new MemoryCache();&#xD;&#xA;        	FileCache fileCache;&#xD;&#xA;        	private Map<ImageView, String> imageViews = Collections&#xD;&#xA;        			.synchronizedMap(new WeakHashMap<ImageView, String>());&#xD;&#xA;        	ExecutorService executorService;&#xD;&#xA;        	// Handler to display images in UI thread&#xD;&#xA;        	Handler handler = new Handler();&#xD;&#xA;        &#xD;&#xA;        	public ImageLoader(Context context) {&#xD;&#xA;        		fileCache = new FileCache(context);&#xD;&#xA;        		executorService = Executors.newFixedThreadPool(5);&#xD;&#xA;        	}&#xD;&#xA;        &#xD;&#xA;        	final int stub_id = R.drawable.temp_img;&#xD;&#xA;        &#xD;&#xA;        	public void DisplayImage(String url, ImageView imageView) {&#xD;&#xA;        		imageViews.put(imageView, url);&#xD;&#xA;        		Bitmap bitmap = memoryCache.get(url);&#xD;&#xA;        		if (bitmap != null)&#xD;&#xA;        			imageView.setImageBitmap(bitmap);&#xD;&#xA;        		else {&#xD;&#xA;        			queuePhoto(url, imageView);&#xD;&#xA;        			imageView.setImageResource(stub_id);&#xD;&#xA;        		}&#xD;&#xA;        	}&#xD;&#xA;        &#xD;&#xA;        	private void queuePhoto(String url, ImageView imageView) {&#xD;&#xA;        		PhotoToLoad p = new PhotoToLoad(url, imageView);&#xD;&#xA;        		executorService.submit(new PhotosLoader(p));&#xD;&#xA;        	}&#xD;&#xA;        &#xD;&#xA;        	private Bitmap getBitmap(String url) {&#xD;&#xA;        		File f = fileCache.getFile(url);&#xD;&#xA;        &#xD;&#xA;        		Bitmap b = decodeFile(f);&#xD;&#xA;        		if (b != null)&#xD;&#xA;        			return b;&#xD;&#xA;        &#xD;&#xA;        		// Download Images from the Internet&#xD;&#xA;        		try {&#xD;&#xA;        			Bitmap bitmap = null;&#xD;&#xA;        			URL imageUrl = new URL(url);&#xD;&#xA;        			HttpURLConnection conn = (HttpURLConnection) imageUrl&#xD;&#xA;        					.openConnection();&#xD;&#xA;        			conn.setConnectTimeout(30000);&#xD;&#xA;        			conn.setReadTimeout(30000);&#xD;&#xA;        			conn.setInstanceFollowRedirects(true);&#xD;&#xA;        			InputStream is = conn.getInputStream();&#xD;&#xA;        			OutputStream os = new FileOutputStream(f);&#xD;&#xA;        			Utils.CopyStream(is, os);&#xD;&#xA;        			os.close();&#xD;&#xA;        			conn.disconnect();&#xD;&#xA;        			bitmap = decodeFile(f);&#xD;&#xA;        			return bitmap;&#xD;&#xA;        		} catch (Throwable ex) {&#xD;&#xA;        			ex.printStackTrace();&#xD;&#xA;        			if (ex instanceof OutOfMemoryError)&#xD;&#xA;        				memoryCache.clear();&#xD;&#xA;        			return null;&#xD;&#xA;        		}&#xD;&#xA;        	}&#xD;&#xA;        &#xD;&#xA;        	// Decodes image and scales it to reduce memory consumption&#xD;&#xA;        	private Bitmap decodeFile(File f) {&#xD;&#xA;        		try {&#xD;&#xA;        			// Decode image size&#xD;&#xA;        			BitmapFactory.Options o = new BitmapFactory.Options();&#xD;&#xA;        			o.inJustDecodeBounds = true;&#xD;&#xA;        			FileInputStream stream1 = new FileInputStream(f);&#xD;&#xA;        			BitmapFactory.decodeStream(stream1, null, o);&#xD;&#xA;        			stream1.close();&#xD;&#xA;        &#xD;&#xA;        			// Find the correct scale value. It should be the power of 2.&#xD;&#xA;        			// Recommended Size 512&#xD;&#xA;        			final int REQUIRED_SIZE = 70;&#xD;&#xA;        			int width_tmp = o.outWidth, height_tmp = o.outHeight;&#xD;&#xA;        			int scale = 1;&#xD;&#xA;        			while (true) {&#xD;&#xA;        				if (width_tmp / 2 < REQUIRED_SIZE&#xD;&#xA;        						|| height_tmp / 2 < REQUIRED_SIZE)&#xD;&#xA;        					break;&#xD;&#xA;        				width_tmp /= 2;&#xD;&#xA;        				height_tmp /= 2;&#xD;&#xA;        				scale *= 2;&#xD;&#xA;        			}&#xD;&#xA;        &#xD;&#xA;        			// Decode with inSampleSize&#xD;&#xA;        			BitmapFactory.Options o2 = new BitmapFactory.Options();&#xD;&#xA;        			o2.inSampleSize = scale;&#xD;&#xA;        			FileInputStream stream2 = new FileInputStream(f);&#xD;&#xA;        			Bitmap bitmap = BitmapFactory.decodeStream(stream2, null, o2);&#xD;&#xA;        			stream2.close();&#xD;&#xA;        			return bitmap;&#xD;&#xA;        		} catch (FileNotFoundException e) {&#xD;&#xA;        		} catch (IOException e) {&#xD;&#xA;        			e.printStackTrace();&#xD;&#xA;        		}&#xD;&#xA;        		return null;&#xD;&#xA;        	}&#xD;&#xA;        &#xD;&#xA;        	// Task for the queue&#xD;&#xA;        	private class PhotoToLoad {&#xD;&#xA;        		public String url;&#xD;&#xA;        		public ImageView imageView;&#xD;&#xA;        &#xD;&#xA;        		public PhotoToLoad(String u, ImageView i) {&#xD;&#xA;        			url = u;&#xD;&#xA;        			imageView = i;&#xD;&#xA;        		}&#xD;&#xA;        	}&#xD;&#xA;        &#xD;&#xA;        	class PhotosLoader implements Runnable {&#xD;&#xA;        		PhotoToLoad photoToLoad;&#xD;&#xA;        &#xD;&#xA;        		PhotosLoader(PhotoToLoad photoToLoad) {&#xD;&#xA;        			this.photoToLoad = photoToLoad;&#xD;&#xA;        		}&#xD;&#xA;        &#xD;&#xA;        		@Override&#xD;&#xA;        		public void run() {&#xD;&#xA;        			try {&#xD;&#xA;        				if (imageViewReused(photoToLoad))&#xD;&#xA;        					return;&#xD;&#xA;        				Bitmap bmp = getBitmap(photoToLoad.url);&#xD;&#xA;        				memoryCache.put(photoToLoad.url, bmp);&#xD;&#xA;        				if (imageViewReused(photoToLoad))&#xD;&#xA;        					return;&#xD;&#xA;        				BitmapDisplayer bd = new BitmapDisplayer(bmp, photoToLoad);&#xD;&#xA;        				handler.post(bd);&#xD;&#xA;        			} catch (Throwable th) {&#xD;&#xA;        				th.printStackTrace();&#xD;&#xA;        			}&#xD;&#xA;        		}&#xD;&#xA;        	}&#xD;&#xA;        &#xD;&#xA;        	boolean imageViewReused(PhotoToLoad photoToLoad) {&#xD;&#xA;        		String tag = imageViews.get(photoToLoad.imageView);&#xD;&#xA;        		if (tag == null || !tag.equals(photoToLoad.url))&#xD;&#xA;        			return true;&#xD;&#xA;        		return false;&#xD;&#xA;        	}&#xD;&#xA;        &#xD;&#xA;        	// Used to display bitmap in the UI thread&#xD;&#xA;        	class BitmapDisplayer implements Runnable {&#xD;&#xA;        		Bitmap bitmap;&#xD;&#xA;        		PhotoToLoad photoToLoad;&#xD;&#xA;        &#xD;&#xA;        		public BitmapDisplayer(Bitmap b, PhotoToLoad p) {&#xD;&#xA;        			bitmap = b;&#xD;&#xA;        			photoToLoad = p;&#xD;&#xA;        		}&#xD;&#xA;        &#xD;&#xA;        		public void run() {&#xD;&#xA;        			if (imageViewReused(photoToLoad))&#xD;&#xA;        				return;&#xD;&#xA;        			if (bitmap != null)&#xD;&#xA;        				photoToLoad.imageView.setImageBitmap(bitmap);&#xD;&#xA;        			else&#xD;&#xA;        				photoToLoad.imageView.setImageResource(stub_id);&#xD;&#xA;        		}&#xD;&#xA;        	}&#xD;&#xA;        &#xD;&#xA;        	public void clearCache() {&#xD;&#xA;        		memoryCache.clear();&#xD;&#xA;        		fileCache.clear();&#xD;&#xA;        	}&#xD;&#xA;        &#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;    "
