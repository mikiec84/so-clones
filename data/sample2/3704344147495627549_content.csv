"Content"
"    // sock is bound AF_INET socket, usually SOCK_DGRAM&#xD;&#xA;    // include struct in_pktinfo in the message """"ancilliary"""" control data&#xD;&#xA;    setsockopt(sock, IPPROTO_IP, IP_PKTINFO, &opt, sizeof(opt));&#xD;&#xA;    // the control data is dumped here&#xD;&#xA;    char cmbuf[0x100];&#xD;&#xA;    // the remote/source sockaddr is put here&#xD;&#xA;    struct sockaddr_in peeraddr;&#xD;&#xA;    // if you want access to the data you need to init the msg_iovec fields&#xD;&#xA;    struct msghdr mh = {&#xD;&#xA;        .msg_name = &peeraddr,&#xD;&#xA;        .msg_namelen = sizeof(peeraddr),&#xD;&#xA;        .msg_control = cmbuf,&#xD;&#xA;        .msg_controllen = sizeof(cmbuf),&#xD;&#xA;    };&#xD;&#xA;    recvmsg(sock, &mh, 0);&#xD;&#xA;    for ( // iterate through all the control headers&#xD;&#xA;        struct cmsghdr *cmsg = CMSG_FIRSTHDR(&mh);&#xD;&#xA;        cmsg != NULL;&#xD;&#xA;        cmsg = CMSG_NXTHDR(&mh, cmsg))&#xD;&#xA;    {&#xD;&#xA;        // ignore the control headers that don't match what we want&#xD;&#xA;        if (cmsg->cmsg_level != IPPROTO_IP ||&#xD;&#xA;            cmsg->cmsg_type != IP_PKTINFO)&#xD;&#xA;        {&#xD;&#xA;            continue;&#xD;&#xA;        }&#xD;&#xA;        struct in_pktinfo *pi = CMSG_DATA(cmsg);&#xD;&#xA;        // at this point, peeraddr is the source sockaddr&#xD;&#xA;        // pi->ipi_spec_dst is the destination in_addr&#xD;&#xA;        // pi->ipi_addr is the receiving interface in_addr&#xD;&#xA;    }"
