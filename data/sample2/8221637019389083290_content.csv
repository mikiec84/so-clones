"Content"
"    enum AESError: Error {&#xD;&#xA;        case KeyError((String, Int))&#xD;&#xA;        case IVError((String, Int))&#xD;&#xA;        case CryptorError((String, Int))&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    // The iv is prefixed to the encrypted data&#xD;&#xA;    func aesCBCEncrypt(data:Data, keyData:Data) throws -> Data {&#xD;&#xA;        let keyLength = keyData.count&#xD;&#xA;        let validKeyLengths = [kCCKeySizeAES128, kCCKeySizeAES192, kCCKeySizeAES256]&#xD;&#xA;        if (validKeyLengths.contains(keyLength) == false) {&#xD;&#xA;            throw AESError.KeyError((""""Invalid key length"""", keyLength))&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        let ivSize = kCCBlockSizeAES128;&#xD;&#xA;        let cryptLength = size_t(ivSize + data.count + kCCBlockSizeAES128)&#xD;&#xA;        var cryptData = Data(count:cryptLength)&#xD;&#xA;    &#xD;&#xA;        let status = cryptData.withUnsafeMutableBytes {ivBytes in&#xD;&#xA;            SecRandomCopyBytes(kSecRandomDefault, kCCBlockSizeAES128, ivBytes)&#xD;&#xA;        }&#xD;&#xA;        if (status != 0) {&#xD;&#xA;            throw AESError.IVError((""""IV generation failed"""", Int(status)))&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        var numBytesEncrypted :size_t = 0&#xD;&#xA;        let options   = CCOptions(kCCOptionPKCS7Padding)&#xD;&#xA;    &#xD;&#xA;        let cryptStatus = cryptData.withUnsafeMutableBytes {cryptBytes in&#xD;&#xA;            data.withUnsafeBytes {dataBytes in&#xD;&#xA;                keyData.withUnsafeBytes {keyBytes in&#xD;&#xA;                    CCCrypt(CCOperation(kCCEncrypt),&#xD;&#xA;                            CCAlgorithm(kCCAlgorithmAES),&#xD;&#xA;                            options,&#xD;&#xA;                            keyBytes, keyLength,&#xD;&#xA;                            cryptBytes,&#xD;&#xA;                            dataBytes, data.count,&#xD;&#xA;                            cryptBytes+kCCBlockSizeAES128, cryptLength,&#xD;&#xA;                            &numBytesEncrypted)&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        if UInt32(cryptStatus) == UInt32(kCCSuccess) {&#xD;&#xA;            cryptData.count = numBytesEncrypted + ivSize&#xD;&#xA;        }&#xD;&#xA;        else {&#xD;&#xA;            throw AESError.CryptorError((""""Encryption failed"""", Int(cryptStatus)))&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        return cryptData;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    // The iv is prefixed to the encrypted data&#xD;&#xA;    func aesCBCDecrypt(data:Data, keyData:Data) throws -> Data? {&#xD;&#xA;        let keyLength = keyData.count&#xD;&#xA;        let validKeyLengths = [kCCKeySizeAES128, kCCKeySizeAES192, kCCKeySizeAES256]&#xD;&#xA;        if (validKeyLengths.contains(keyLength) == false) {&#xD;&#xA;            throw AESError.KeyError((""""Invalid key length"""", keyLength))&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        let ivSize = kCCBlockSizeAES128;&#xD;&#xA;        let clearLength = size_t(data.count - ivSize)&#xD;&#xA;        var clearData = Data(count:clearLength)&#xD;&#xA;    &#xD;&#xA;        var numBytesDecrypted :size_t = 0&#xD;&#xA;        let options   = CCOptions(kCCOptionPKCS7Padding)&#xD;&#xA;    &#xD;&#xA;        let cryptStatus = clearData.withUnsafeMutableBytes {cryptBytes in&#xD;&#xA;            data.withUnsafeBytes {dataBytes in&#xD;&#xA;                keyData.withUnsafeBytes {keyBytes in&#xD;&#xA;                    CCCrypt(CCOperation(kCCDecrypt),&#xD;&#xA;                            CCAlgorithm(kCCAlgorithmAES128),&#xD;&#xA;                            options,&#xD;&#xA;                            keyBytes, keyLength,&#xD;&#xA;                            dataBytes,&#xD;&#xA;                            dataBytes+kCCBlockSizeAES128, clearLength,&#xD;&#xA;                            cryptBytes, clearLength,&#xD;&#xA;                            &numBytesDecrypted)&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        if UInt32(cryptStatus) == UInt32(kCCSuccess) {&#xD;&#xA;            clearData.count = numBytesDecrypted&#xD;&#xA;        }&#xD;&#xA;        else {&#xD;&#xA;            throw AESError.CryptorError((""""Decryption failed"""", Int(cryptStatus)))&#xD;&#xA;        }&#xD;&#xA;        &#xD;&#xA;        return clearData;&#xD;&#xA;    }"
