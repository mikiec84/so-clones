"Content"
"    import java.io.IOException;&#xD;&#xA;    import java.io.OutputStream;&#xD;&#xA;    import java.util.concurrent.*;&#xD;&#xA;    &#xD;&#xA;    public class QueueOutputStream extends OutputStream&#xD;&#xA;    {&#xD;&#xA;      private static final int DEFAULT_BUFFER_SIZE=1024;&#xD;&#xA;      private static final byte[] END_SIGNAL=new byte[]{};&#xD;&#xA;    &#xD;&#xA;      private final BlockingQueue<byte[]> queue=new LinkedBlockingDeque<>();&#xD;&#xA;      private final byte[] buffer;&#xD;&#xA;    &#xD;&#xA;      private boolean closed=false;&#xD;&#xA;      private int count=0;&#xD;&#xA;    &#xD;&#xA;      public QueueOutputStream()&#xD;&#xA;      {&#xD;&#xA;        this(DEFAULT_BUFFER_SIZE);&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      public QueueOutputStream(final int bufferSize)&#xD;&#xA;      {&#xD;&#xA;        if(bufferSize<=0){&#xD;&#xA;          throw new IllegalArgumentException(""""Buffer size <= 0"""");&#xD;&#xA;        }&#xD;&#xA;        this.buffer=new byte[bufferSize];&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      private synchronized void flushBuffer()&#xD;&#xA;      {&#xD;&#xA;        if(count>0){&#xD;&#xA;          final byte[] copy=new byte[count];&#xD;&#xA;          System.arraycopy(buffer,0,copy,0,count);&#xD;&#xA;          queue.offer(copy);&#xD;&#xA;          count=0;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      @Override&#xD;&#xA;      public synchronized void write(final int b) throws IOException&#xD;&#xA;      {&#xD;&#xA;        if(closed){&#xD;&#xA;          throw new IllegalStateException(""""Stream is closed"""");&#xD;&#xA;        }&#xD;&#xA;        if(count>=buffer.length){&#xD;&#xA;          flushBuffer();&#xD;&#xA;        }&#xD;&#xA;        buffer[count++]=(byte)b;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      @Override&#xD;&#xA;      public synchronized void write(final byte[] b, final int off, final int len) throws IOException&#xD;&#xA;      {&#xD;&#xA;        super.write(b,off,len);&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      @Override&#xD;&#xA;      public synchronized void close() throws IOException&#xD;&#xA;      {&#xD;&#xA;        flushBuffer();&#xD;&#xA;        queue.offer(END_SIGNAL);&#xD;&#xA;        closed=true;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      public Future<Void> asyncSendToOutputStream(final ExecutorService executor, final OutputStream outputStream)&#xD;&#xA;      {&#xD;&#xA;        return executor.submit(&#xD;&#xA;                new Callable<Void>()&#xD;&#xA;                {&#xD;&#xA;                  @Override&#xD;&#xA;                  public Void call() throws Exception&#xD;&#xA;                  {&#xD;&#xA;                    try{&#xD;&#xA;                      byte[] buffer=queue.take();&#xD;&#xA;                      while(buffer!=END_SIGNAL){&#xD;&#xA;                        outputStream.write(buffer);&#xD;&#xA;                        buffer=queue.take();&#xD;&#xA;                      }&#xD;&#xA;                      outputStream.flush();&#xD;&#xA;                    } catch(Exception e){&#xD;&#xA;                      close();&#xD;&#xA;                      throw e;&#xD;&#xA;                    } finally{&#xD;&#xA;                      outputStream.close();&#xD;&#xA;                    }&#xD;&#xA;                    return null;&#xD;&#xA;                  }&#xD;&#xA;                }&#xD;&#xA;        );&#xD;&#xA;      }"
