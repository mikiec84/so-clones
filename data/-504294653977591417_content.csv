"Content"
"    // Extended TabControl which saves the displayed item so you don't get the performance hit of &#xD;&#xA;    // unloading and reloading the VisualTree when switching tabs&#xD;&#xA;    &#xD;&#xA;    // Obtained from http://eric.burke.name/dotnetmania/2009/04/26/22.09.28&#xD;&#xA;    // and made a some modifications so it reuses a TabItem's ContentPresenter when doing drag/drop operations&#xD;&#xA;    &#xD;&#xA;    [TemplatePart(Name = """"PART_ItemsHolder"""", Type = typeof(Panel))]&#xD;&#xA;    public class TabControlEx : System.Windows.Controls.TabControl&#xD;&#xA;    {&#xD;&#xA;        // Holds all items, but only marks the current tab's item as visible&#xD;&#xA;        private Panel _itemsHolder = null;&#xD;&#xA;    &#xD;&#xA;        // Temporaily holds deleted item in case this was a drag/drop operation&#xD;&#xA;        private object _deletedObject = null;&#xD;&#xA;    &#xD;&#xA;        public TabControlEx()&#xD;&#xA;            : base()&#xD;&#xA;        {&#xD;&#xA;            // this is necessary so that we get the initial databound selected item&#xD;&#xA;            this.ItemContainerGenerator.StatusChanged += ItemContainerGenerator_StatusChanged;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        /// <summary>&#xD;&#xA;        /// if containers are done, generate the selected item&#xD;&#xA;        /// </summary>&#xD;&#xA;        /// <param name=""""sender""""></param>&#xD;&#xA;        /// <param name=""""e""""></param>&#xD;&#xA;        void ItemContainerGenerator_StatusChanged(object sender, EventArgs e)&#xD;&#xA;        {&#xD;&#xA;            if (this.ItemContainerGenerator.Status == GeneratorStatus.ContainersGenerated)&#xD;&#xA;            {&#xD;&#xA;                this.ItemContainerGenerator.StatusChanged -= ItemContainerGenerator_StatusChanged;&#xD;&#xA;                UpdateSelectedItem();&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        /// <summary>&#xD;&#xA;        /// get the ItemsHolder and generate any children&#xD;&#xA;        /// </summary>&#xD;&#xA;        public override void OnApplyTemplate()&#xD;&#xA;        {&#xD;&#xA;            base.OnApplyTemplate();&#xD;&#xA;            _itemsHolder = GetTemplateChild(""""PART_ItemsHolder"""") as Panel;&#xD;&#xA;            UpdateSelectedItem();&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        /// <summary>&#xD;&#xA;        /// when the items change we remove any generated panel children and add any new ones as necessary&#xD;&#xA;        /// </summary>&#xD;&#xA;        /// <param name=""""e""""></param>&#xD;&#xA;        protected override void OnItemsChanged(NotifyCollectionChangedEventArgs e)&#xD;&#xA;        {&#xD;&#xA;            base.OnItemsChanged(e);&#xD;&#xA;    &#xD;&#xA;            if (_itemsHolder == null)&#xD;&#xA;            {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;    &#xD;&#xA;            switch (e.Action)&#xD;&#xA;            {&#xD;&#xA;                case NotifyCollectionChangedAction.Reset:&#xD;&#xA;                    _itemsHolder.Children.Clear();&#xD;&#xA;    &#xD;&#xA;                    if (base.Items.Count > 0)&#xD;&#xA;                    {&#xD;&#xA;                        base.SelectedItem = base.Items[0];&#xD;&#xA;                        UpdateSelectedItem();&#xD;&#xA;                    }&#xD;&#xA;    &#xD;&#xA;                    break;&#xD;&#xA;    &#xD;&#xA;                case NotifyCollectionChangedAction.Add:&#xD;&#xA;                case NotifyCollectionChangedAction.Remove:&#xD;&#xA;    &#xD;&#xA;                    // Search for recently deleted items caused by a Drag/Drop operation&#xD;&#xA;                    if (e.NewItems != null && _deletedObject != null)&#xD;&#xA;                    {&#xD;&#xA;                        foreach (var item in e.NewItems)&#xD;&#xA;                        {&#xD;&#xA;                            if (_deletedObject == item)&#xD;&#xA;                            {&#xD;&#xA;                                // If the new item is the same as the recently deleted one (i.e. a drag/drop event)&#xD;&#xA;                                // then cancel the deletion and reuse the ContentPresenter so it doesn't have to be &#xD;&#xA;                                // redrawn. We do need to link the presenter to the new item though (using the Tag)&#xD;&#xA;                                ContentPresenter cp = FindChildContentPresenter(_deletedObject);&#xD;&#xA;                                if (cp != null)&#xD;&#xA;                                {&#xD;&#xA;                                    int index = _itemsHolder.Children.IndexOf(cp);&#xD;&#xA;    &#xD;&#xA;                                    (_itemsHolder.Children[index] as ContentPresenter).Tag =&#xD;&#xA;                                        (item is TabItem) ? item : (this.ItemContainerGenerator.ContainerFromItem(item));&#xD;&#xA;                                }&#xD;&#xA;                                _deletedObject = null;&#xD;&#xA;                            }&#xD;&#xA;                        }&#xD;&#xA;                    }&#xD;&#xA;    &#xD;&#xA;                    if (e.OldItems != null)&#xD;&#xA;                    {&#xD;&#xA;                        foreach (var item in e.OldItems)&#xD;&#xA;                        {&#xD;&#xA;    &#xD;&#xA;                            _deletedObject = item;&#xD;&#xA;    &#xD;&#xA;                            // We want to run this at a slightly later priority in case this&#xD;&#xA;                            // is a drag/drop operation so that we can reuse the template&#xD;&#xA;                            this.Dispatcher.BeginInvoke(DispatcherPriority.DataBind,&#xD;&#xA;                                new Action(delegate()&#xD;&#xA;                            {&#xD;&#xA;                                if (_deletedObject != null)&#xD;&#xA;                                {&#xD;&#xA;                                    ContentPresenter cp = FindChildContentPresenter(_deletedObject);&#xD;&#xA;                                    if (cp != null)&#xD;&#xA;                                    {&#xD;&#xA;                                        this._itemsHolder.Children.Remove(cp);&#xD;&#xA;                                    }&#xD;&#xA;                                }&#xD;&#xA;                            }&#xD;&#xA;                            ));&#xD;&#xA;                        }&#xD;&#xA;                    }&#xD;&#xA;    &#xD;&#xA;                    UpdateSelectedItem();&#xD;&#xA;                    break;&#xD;&#xA;    &#xD;&#xA;                case NotifyCollectionChangedAction.Replace:&#xD;&#xA;                    throw new NotImplementedException(""""Replace not implemented yet"""");&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        /// <summary>&#xD;&#xA;        /// update the visible child in the ItemsHolder&#xD;&#xA;        /// </summary>&#xD;&#xA;        /// <param name=""""e""""></param>&#xD;&#xA;        protected override void OnSelectionChanged(SelectionChangedEventArgs e)&#xD;&#xA;        {&#xD;&#xA;            base.OnSelectionChanged(e);&#xD;&#xA;            UpdateSelectedItem();&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        /// <summary>&#xD;&#xA;        /// generate a ContentPresenter for the selected item&#xD;&#xA;        /// </summary>&#xD;&#xA;        void UpdateSelectedItem()&#xD;&#xA;        {&#xD;&#xA;            if (_itemsHolder == null)&#xD;&#xA;            {&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;    &#xD;&#xA;            // generate a ContentPresenter if necessary&#xD;&#xA;            TabItem item = GetSelectedTabItem();&#xD;&#xA;            if (item != null)&#xD;&#xA;            {&#xD;&#xA;                CreateChildContentPresenter(item);&#xD;&#xA;            }&#xD;&#xA;    &#xD;&#xA;            // show the right child&#xD;&#xA;            foreach (ContentPresenter child in _itemsHolder.Children)&#xD;&#xA;            {&#xD;&#xA;                child.Visibility = ((child.Tag as TabItem).IsSelected) ? Visibility.Visible : Visibility.Collapsed;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        /// <summary>&#xD;&#xA;        /// create the child ContentPresenter for the given item (could be data or a TabItem)&#xD;&#xA;        /// </summary>&#xD;&#xA;        /// <param name=""""item""""></param>&#xD;&#xA;        /// <returns></returns>&#xD;&#xA;        ContentPresenter CreateChildContentPresenter(object item)&#xD;&#xA;        {&#xD;&#xA;            if (item == null)&#xD;&#xA;            {&#xD;&#xA;                return null;&#xD;&#xA;            }&#xD;&#xA;    &#xD;&#xA;            ContentPresenter cp = FindChildContentPresenter(item);&#xD;&#xA;    &#xD;&#xA;            if (cp != null)&#xD;&#xA;            {&#xD;&#xA;                return cp;&#xD;&#xA;            }&#xD;&#xA;    &#xD;&#xA;            // the actual child to be added.  cp.Tag is a reference to the TabItem&#xD;&#xA;            cp = new ContentPresenter();&#xD;&#xA;            cp.Content = (item is TabItem) ? (item as TabItem).Content : item;&#xD;&#xA;            cp.ContentTemplate = this.SelectedContentTemplate;&#xD;&#xA;            cp.ContentTemplateSelector = this.SelectedContentTemplateSelector;&#xD;&#xA;            cp.ContentStringFormat = this.SelectedContentStringFormat;&#xD;&#xA;            cp.Visibility = Visibility.Collapsed;&#xD;&#xA;            cp.Tag = (item is TabItem) ? item : (this.ItemContainerGenerator.ContainerFromItem(item));&#xD;&#xA;            _itemsHolder.Children.Add(cp);&#xD;&#xA;            return cp;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        /// <summary>&#xD;&#xA;        /// Find the CP for the given object.  data could be a TabItem or a piece of data&#xD;&#xA;        /// </summary>&#xD;&#xA;        /// <param name=""""data""""></param>&#xD;&#xA;        /// <returns></returns>&#xD;&#xA;        ContentPresenter FindChildContentPresenter(object data)&#xD;&#xA;        {&#xD;&#xA;            if (data is TabItem)&#xD;&#xA;            {&#xD;&#xA;                data = (data as TabItem).Content;&#xD;&#xA;            }&#xD;&#xA;    &#xD;&#xA;            if (data == null)&#xD;&#xA;            {&#xD;&#xA;                return null;&#xD;&#xA;            }&#xD;&#xA;    &#xD;&#xA;            if (_itemsHolder == null)&#xD;&#xA;            {&#xD;&#xA;                return null;&#xD;&#xA;            }&#xD;&#xA;    &#xD;&#xA;            foreach (ContentPresenter cp in _itemsHolder.Children)&#xD;&#xA;            {&#xD;&#xA;                if (cp.Content == data)&#xD;&#xA;                {&#xD;&#xA;                    return cp;&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;    &#xD;&#xA;            return null;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        /// <summary>&#xD;&#xA;        /// copied from TabControl; wish it were protected in that class instead of private&#xD;&#xA;        /// </summary>&#xD;&#xA;        /// <returns></returns>&#xD;&#xA;        protected TabItem GetSelectedTabItem()&#xD;&#xA;        {&#xD;&#xA;            object selectedItem = base.SelectedItem;&#xD;&#xA;            if (selectedItem == null)&#xD;&#xA;            {&#xD;&#xA;                return null;&#xD;&#xA;            }&#xD;&#xA;    &#xD;&#xA;            if (_deletedObject == selectedItem)&#xD;&#xA;            { &#xD;&#xA;    &#xD;&#xA;            }&#xD;&#xA;    &#xD;&#xA;            TabItem item = selectedItem as TabItem;&#xD;&#xA;            if (item == null)&#xD;&#xA;            {&#xD;&#xA;                item = base.ItemContainerGenerator.ContainerFromIndex(base.SelectedIndex) as TabItem;&#xD;&#xA;            }&#xD;&#xA;            return item;&#xD;&#xA;        }&#xD;&#xA;    }"
