"Content"
"    @if (@X)==(@Y) @end /* Harmless hybrid line that begins a JScript comment&#xD;&#xA;    &#xD;&#xA;    ::************ Documentation ***********&#xD;&#xA;    :::&#xD;&#xA;    :::REPL  Search  Replace  [Options  [SourceVar]]&#xD;&#xA;    :::REPL  /?&#xD;&#xA;    :::&#xD;&#xA;    :::  Performs a global search and replace operation on each line of input from&#xD;&#xA;    :::  stdin and prints the result to stdout.&#xD;&#xA;    :::&#xD;&#xA;    :::  Each parameter may be optionally enclosed by double quotes. The double&#xD;&#xA;    :::  quotes are not considered part of the argument. The quotes are required&#xD;&#xA;    :::  if the parameter contains a batch token delimiter like space, tab, comma,&#xD;&#xA;    :::  semicolon. The quotes should also be used if the argument contains a&#xD;&#xA;    :::  batch special character like &, |, etc. so that the special character&#xD;&#xA;    :::  does not need to be escaped with ^.&#xD;&#xA;    :::&#xD;&#xA;    :::  If called with a single argument of /? then prints help documentation&#xD;&#xA;    :::  to stdout.&#xD;&#xA;    :::&#xD;&#xA;    :::  Search  - By default this is a case sensitive JScript (ECMA) regular&#xD;&#xA;    :::            expression expressed as a string.&#xD;&#xA;    :::&#xD;&#xA;    :::            JScript syntax documentation is available at&#xD;&#xA;    :::            http://msdn.microsoft.com/en-us/library/ae5bf541(v=vs.80).aspx&#xD;&#xA;    :::&#xD;&#xA;    :::  Replace - By default this is the string to be used as a replacement for&#xD;&#xA;    :::            each found search expression. Full support is provided for&#xD;&#xA;    :::            substituion patterns available to the JScript replace method.&#xD;&#xA;    :::            A $ literal can be escaped as $$. An empty replacement string&#xD;&#xA;    :::            must be represented as """""""".&#xD;&#xA;    :::&#xD;&#xA;    :::            Replace substitution pattern syntax is documented at&#xD;&#xA;    :::            http://msdn.microsoft.com/en-US/library/efy6s3e6(v=vs.80).aspx&#xD;&#xA;    :::&#xD;&#xA;    :::  Options - An optional string of characters used to alter the behavior&#xD;&#xA;    :::            of REPL. The option characters are case insensitive, and may&#xD;&#xA;    :::            appear in any order.&#xD;&#xA;    :::&#xD;&#xA;    :::            I - Makes the search case-insensitive.&#xD;&#xA;    :::&#xD;&#xA;    :::            L - The Search is treated as a string literal instead of a&#xD;&#xA;    :::                regular expression. Also, all $ found in Replace are&#xD;&#xA;    :::                treated as $ literals.&#xD;&#xA;    :::&#xD;&#xA;    :::            E - Search and Replace represent the name of environment&#xD;&#xA;    :::                variables that contain the respective values. An undefined&#xD;&#xA;    :::                variable is treated as an empty string.&#xD;&#xA;    :::&#xD;&#xA;    :::            M - Multi-line mode. The entire contents of stdin is read and&#xD;&#xA;    :::                processed in one pass instead of line by line. ^ anchors&#xD;&#xA;    :::                the beginning of a line and $ anchors the end of a line.&#xD;&#xA;    :::&#xD;&#xA;    :::            X - Enables extended substitution pattern syntax with support&#xD;&#xA;    :::                for the following escape sequences:&#xD;&#xA;    :::&#xD;&#xA;    :::                \\     -  Backslash&#xD;&#xA;    :::                \b     -  Backspace&#xD;&#xA;    :::                \f     -  Formfeed&#xD;&#xA;    :::                \n     -  Newline&#xD;&#xA;    :::                \r     -  Carriage Return&#xD;&#xA;    :::                \t     -  Horizontal Tab&#xD;&#xA;    :::                \v     -  Vertical Tab&#xD;&#xA;    :::                \xnn   -  Ascii (Latin 1) character expressed as 2 hex digits&#xD;&#xA;    :::                \unnnn -  Unicode character expressed as 4 hex digits&#xD;&#xA;    :::&#xD;&#xA;    :::                Escape sequences are supported even when the L option is used.&#xD;&#xA;    :::&#xD;&#xA;    :::            S - The source is read from an environment variable instead of&#xD;&#xA;    :::                from stdin. The name of the source environment variable is&#xD;&#xA;    :::                specified in the next argument after the option string.&#xD;&#xA;    :::&#xD;&#xA;     &#xD;&#xA;    ::************ Batch portion ***********&#xD;&#xA;    @echo off&#xD;&#xA;    if .%2 equ . (&#xD;&#xA;      if """"%~1"""" equ """"/?"""" (&#xD;&#xA;        findstr """"^:::"""" """"%~f0"""" | cscript //E:JScript //nologo """"%~f0"""" """"^:::"""" """"""""&#xD;&#xA;        exit /b 0&#xD;&#xA;      ) else (&#xD;&#xA;        call :err """"Insufficient arguments""""&#xD;&#xA;        exit /b 1&#xD;&#xA;      )&#xD;&#xA;    )&#xD;&#xA;    echo(%~3|findstr /i """"[^SMILEX]"""" >nul && (&#xD;&#xA;      call :err """"Invalid option(s)""""&#xD;&#xA;      exit /b 1&#xD;&#xA;    )&#xD;&#xA;    cscript //E:JScript //nologo """"%~f0"""" %*&#xD;&#xA;    exit /b 0&#xD;&#xA;    &#xD;&#xA;    :err&#xD;&#xA;    >&2 echo ERROR: %~1. Use REPL /? to get help.&#xD;&#xA;    exit /b&#xD;&#xA;    &#xD;&#xA;    ************* JScript portion **********/&#xD;&#xA;    var env=WScript.CreateObject(""""WScript.Shell"""").Environment(""""Process"""");&#xD;&#xA;    var args=WScript.Arguments;&#xD;&#xA;    var search=args.Item(0);&#xD;&#xA;    var replace=args.Item(1);&#xD;&#xA;    var options=""""g"""";&#xD;&#xA;    if (args.length>2) {&#xD;&#xA;      options+=args.Item(2).toLowerCase();&#xD;&#xA;    }&#xD;&#xA;    var multi=(options.indexOf(""""m"""")>=0);&#xD;&#xA;    var srcVar=(options.indexOf(""""s"""")>=0);&#xD;&#xA;    if (srcVar) {&#xD;&#xA;      options=options.replace(/s/g,"""""""");&#xD;&#xA;    }&#xD;&#xA;    if (options.indexOf(""""e"""")>=0) {&#xD;&#xA;      options=options.replace(/e/g,"""""""");&#xD;&#xA;      search=env(search);&#xD;&#xA;      replace=env(replace);&#xD;&#xA;    }&#xD;&#xA;    if (options.indexOf(""""l"""")>=0) {&#xD;&#xA;      options=options.replace(/l/g,"""""""");&#xD;&#xA;      search=search.replace(/([.^$*+?()[{\\|])/g,""""\\$1"""");&#xD;&#xA;      replace=replace.replace(/\$/g,""""$$$$"""");&#xD;&#xA;    }&#xD;&#xA;    if (options.indexOf(""""x"""")>=0) {&#xD;&#xA;      options=options.replace(/x/g,"""""""");&#xD;&#xA;      replace=replace.replace(/\\\\/g,""""\\B"""");&#xD;&#xA;      replace=replace.replace(/\\b/g,""""\b"""");&#xD;&#xA;      replace=replace.replace(/\\f/g,""""\f"""");&#xD;&#xA;      replace=replace.replace(/\\n/g,""""\n"""");&#xD;&#xA;      replace=replace.replace(/\\r/g,""""\r"""");&#xD;&#xA;      replace=replace.replace(/\\t/g,""""\t"""");&#xD;&#xA;      replace=replace.replace(/\\v/g,""""\v"""");&#xD;&#xA;      replace=replace.replace(/\\x[0-9a-fA-F]{2}|\\u[0-9a-fA-F]{4}/g,&#xD;&#xA;        function($0,$1,$2){&#xD;&#xA;          return String.fromCharCode(parseInt(""""0x""""+$0.substring(2)));&#xD;&#xA;        }&#xD;&#xA;      );&#xD;&#xA;      replace=replace.replace(/\\B/g,""""\\"""");&#xD;&#xA;    }&#xD;&#xA;    var search=new RegExp(search,options);&#xD;&#xA;    &#xD;&#xA;    if (srcVar) {&#xD;&#xA;      WScript.Stdout.Write(env(args.Item(3)).replace(search,replace));&#xD;&#xA;    } else {&#xD;&#xA;      while (!WScript.StdIn.AtEndOfStream) {&#xD;&#xA;        if (multi) {&#xD;&#xA;          WScript.Stdout.Write(WScript.StdIn.ReadAll().replace(search,replace));&#xD;&#xA;        } else {&#xD;&#xA;          WScript.Stdout.WriteLine(WScript.StdIn.ReadLine().replace(search,replace));&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    }"
