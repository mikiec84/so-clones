"Content"
"    public class QueueLinearFloodFiller {&#xD;&#xA;		protected Bitmap image = null;&#xD;&#xA;		protected int[] tolerance = new int[] { 0, 0, 0 };&#xD;&#xA;		protected int width = 0;&#xD;&#xA;		protected int height = 0;&#xD;&#xA;		protected int[] pixels = null;&#xD;&#xA;		protected int fillColor = 0;&#xD;&#xA;		protected int[] startColor = new int[] { 0, 0, 0 };&#xD;&#xA;		protected boolean[] pixelsChecked;&#xD;&#xA;		protected Queue<FloodFillRange> ranges;&#xD;&#xA;	&#xD;&#xA;		// Construct using an image and a copy will be made to fill into,&#xD;&#xA;		// Construct with BufferedImage and flood fill will write directly to&#xD;&#xA;		// provided BufferedImage&#xD;&#xA;		public QueueLinearFloodFiller(Bitmap img) {&#xD;&#xA;			copyImage(img);&#xD;&#xA;		}&#xD;&#xA;	&#xD;&#xA;		public QueueLinearFloodFiller(Bitmap img, int targetColor, int newColor) {&#xD;&#xA;			useImage(img);&#xD;&#xA;	&#xD;&#xA;			setFillColor(newColor);&#xD;&#xA;			setTargetColor(targetColor);&#xD;&#xA;		}&#xD;&#xA;	&#xD;&#xA;		public void setTargetColor(int targetColor) {&#xD;&#xA;			startColor[0] = Color.red(targetColor);&#xD;&#xA;			startColor[1] = Color.green(targetColor);&#xD;&#xA;			startColor[2] = Color.blue(targetColor);&#xD;&#xA;		}&#xD;&#xA;	&#xD;&#xA;		public int getFillColor() {&#xD;&#xA;			return fillColor;&#xD;&#xA;		}&#xD;&#xA;	&#xD;&#xA;		public void setFillColor(int value) {&#xD;&#xA;			fillColor = value;&#xD;&#xA;		}&#xD;&#xA;	&#xD;&#xA;		public int[] getTolerance() {&#xD;&#xA;			return tolerance;&#xD;&#xA;		}&#xD;&#xA;	&#xD;&#xA;		public void setTolerance(int[] value) {&#xD;&#xA;			tolerance = value;&#xD;&#xA;		}&#xD;&#xA;	&#xD;&#xA;		public void setTolerance(int value) {&#xD;&#xA;			tolerance = new int[] { value, value, value };&#xD;&#xA;		}&#xD;&#xA;	&#xD;&#xA;		public Bitmap getImage() {&#xD;&#xA;			return image;&#xD;&#xA;		}&#xD;&#xA;	&#xD;&#xA;		public void copyImage(Bitmap img) {&#xD;&#xA;			// Copy data from provided Image to a BufferedImage to write flood fill&#xD;&#xA;			// to, use getImage to retrieve&#xD;&#xA;			// cache data in member variables to decrease overhead of property calls&#xD;&#xA;			width = img.getWidth();&#xD;&#xA;			height = img.getHeight();&#xD;&#xA;	&#xD;&#xA;			image = Bitmap.createBitmap(width, height, Bitmap.Config.RGB_565);&#xD;&#xA;			Canvas canvas = new Canvas(image);&#xD;&#xA;			canvas.drawBitmap(img, 0, 0, null);&#xD;&#xA;	&#xD;&#xA;			pixels = new int[width * height];&#xD;&#xA;	&#xD;&#xA;			image.getPixels(pixels, 0, width, 1, 1, width - 1, height - 1);&#xD;&#xA;		}&#xD;&#xA;	&#xD;&#xA;		public void useImage(Bitmap img) {&#xD;&#xA;			// Use a pre-existing provided BufferedImage and write directly to it&#xD;&#xA;			// cache data in member variables to decrease overhead of property calls&#xD;&#xA;			width = img.getWidth();&#xD;&#xA;			height = img.getHeight();&#xD;&#xA;			image = img;&#xD;&#xA;	&#xD;&#xA;			pixels = new int[width * height];&#xD;&#xA;	&#xD;&#xA;			image.getPixels(pixels, 0, width, 1, 1, width - 1, height - 1);&#xD;&#xA;		}&#xD;&#xA;	&#xD;&#xA;		protected void prepare() {&#xD;&#xA;			// Called before starting flood-fill&#xD;&#xA;			pixelsChecked = new boolean[pixels.length];&#xD;&#xA;			ranges = new LinkedList<FloodFillRange>();&#xD;&#xA;		}&#xD;&#xA;	&#xD;&#xA;		// Fills the specified point on the bitmap with the currently selected fill&#xD;&#xA;		// color.&#xD;&#xA;		// int x, int y: The starting coords for the fill&#xD;&#xA;		public void floodFill(int x, int y) {&#xD;&#xA;			// Setup&#xD;&#xA;			prepare();&#xD;&#xA;	&#xD;&#xA;			if (startColor[0] == 0) {&#xD;&#xA;				// ***Get starting color.&#xD;&#xA;				int startPixel = pixels[(width * y) + x];&#xD;&#xA;				startColor[0] = (startPixel >> 16) & 0xff;&#xD;&#xA;				startColor[1] = (startPixel >> 8) & 0xff;&#xD;&#xA;				startColor[2] = startPixel & 0xff;&#xD;&#xA;			}&#xD;&#xA;	&#xD;&#xA;			// ***Do first call to floodfill.&#xD;&#xA;			LinearFill(x, y);&#xD;&#xA;	&#xD;&#xA;			// ***Call floodfill routine while floodfill ranges still exist on the&#xD;&#xA;			// queue&#xD;&#xA;			FloodFillRange range;&#xD;&#xA;	&#xD;&#xA;			while (ranges.size() > 0) {&#xD;&#xA;				// **Get Next Range Off the Queue&#xD;&#xA;				range = ranges.remove();&#xD;&#xA;	&#xD;&#xA;				// **Check Above and Below Each Pixel in the Floodfill Range&#xD;&#xA;				int downPxIdx = (width * (range.Y + 1)) + range.startX;&#xD;&#xA;				int upPxIdx = (width * (range.Y - 1)) + range.startX;&#xD;&#xA;				int upY = range.Y - 1;// so we can pass the y coord by ref&#xD;&#xA;				int downY = range.Y + 1;&#xD;&#xA;	&#xD;&#xA;				for (int i = range.startX; i <= range.endX; i++) {&#xD;&#xA;					// *Start Fill Upwards&#xD;&#xA;					// if we're not above the top of the bitmap and the pixel above&#xD;&#xA;					// this one is within the color tolerance&#xD;&#xA;					if (range.Y > 0 && (!pixelsChecked[upPxIdx])&#xD;&#xA;							&& CheckPixel(upPxIdx))&#xD;&#xA;						LinearFill(i, upY);&#xD;&#xA;	&#xD;&#xA;					// *Start Fill Downwards&#xD;&#xA;					// if we're not below the bottom of the bitmap and the pixel&#xD;&#xA;					// below this one is within the color tolerance&#xD;&#xA;					if (range.Y < (height - 1) && (!pixelsChecked[downPxIdx])&#xD;&#xA;							&& CheckPixel(downPxIdx))&#xD;&#xA;						LinearFill(i, downY);&#xD;&#xA;	&#xD;&#xA;					downPxIdx++;&#xD;&#xA;					upPxIdx++;&#xD;&#xA;				}&#xD;&#xA;			}&#xD;&#xA;	&#xD;&#xA;			image.setPixels(pixels, 0, width, 1, 1, width - 1, height - 1);&#xD;&#xA;		}&#xD;&#xA;	&#xD;&#xA;		// Finds the furthermost left and right boundaries of the fill area&#xD;&#xA;		// on a given y coordinate, starting from a given x coordinate, filling as&#xD;&#xA;		// it goes.&#xD;&#xA;		// Adds the resulting horizontal range to the queue of floodfill ranges,&#xD;&#xA;		// to be processed in the main loop.&#xD;&#xA;	&#xD;&#xA;		// int x, int y: The starting coords&#xD;&#xA;		protected void LinearFill(int x, int y) {&#xD;&#xA;			// ***Find Left Edge of Color Area&#xD;&#xA;			int lFillLoc = x; // the location to check/fill on the left&#xD;&#xA;			int pxIdx = (width * y) + x;&#xD;&#xA;	&#xD;&#xA;			while (true) {&#xD;&#xA;				// **fill with the color&#xD;&#xA;				pixels[pxIdx] = fillColor;&#xD;&#xA;	&#xD;&#xA;				// **indicate that this pixel has already been checked and filled&#xD;&#xA;				pixelsChecked[pxIdx] = true;&#xD;&#xA;	&#xD;&#xA;				// **de-increment&#xD;&#xA;				lFillLoc--; // de-increment counter&#xD;&#xA;				pxIdx--; // de-increment pixel index&#xD;&#xA;	&#xD;&#xA;				// **exit loop if we're at edge of bitmap or color area&#xD;&#xA;				if (lFillLoc < 0 || (pixelsChecked[pxIdx]) || !CheckPixel(pxIdx)) {&#xD;&#xA;					break;&#xD;&#xA;				}&#xD;&#xA;			}&#xD;&#xA;	&#xD;&#xA;			lFillLoc++;&#xD;&#xA;	&#xD;&#xA;			// ***Find Right Edge of Color Area&#xD;&#xA;			int rFillLoc = x; // the location to check/fill on the left&#xD;&#xA;	&#xD;&#xA;			pxIdx = (width * y) + x;&#xD;&#xA;	&#xD;&#xA;			while (true) {&#xD;&#xA;				// **fill with the color&#xD;&#xA;				pixels[pxIdx] = fillColor;&#xD;&#xA;	&#xD;&#xA;				// **indicate that this pixel has already been checked and filled&#xD;&#xA;				pixelsChecked[pxIdx] = true;&#xD;&#xA;	&#xD;&#xA;				// **increment&#xD;&#xA;				rFillLoc++; // increment counter&#xD;&#xA;				pxIdx++; // increment pixel index&#xD;&#xA;	&#xD;&#xA;				// **exit loop if we're at edge of bitmap or color area&#xD;&#xA;				if (rFillLoc >= width || pixelsChecked[pxIdx] || !CheckPixel(pxIdx)) {&#xD;&#xA;					break;&#xD;&#xA;				}&#xD;&#xA;			}&#xD;&#xA;	&#xD;&#xA;			rFillLoc--;&#xD;&#xA;	&#xD;&#xA;			// add range to queue&#xD;&#xA;			FloodFillRange r = new FloodFillRange(lFillLoc, rFillLoc, y);&#xD;&#xA;	&#xD;&#xA;			ranges.offer(r);&#xD;&#xA;		}&#xD;&#xA;	&#xD;&#xA;		// Sees if a pixel is within the color tolerance range.&#xD;&#xA;		protected boolean CheckPixel(int px) {&#xD;&#xA;			int red = (pixels[px] >>> 16) & 0xff;&#xD;&#xA;			int green = (pixels[px] >>> 8) & 0xff;&#xD;&#xA;			int blue = pixels[px] & 0xff;&#xD;&#xA;	&#xD;&#xA;			return (red >= (startColor[0] - tolerance[0])&#xD;&#xA;					&& red <= (startColor[0] + tolerance[0])&#xD;&#xA;					&& green >= (startColor[1] - tolerance[1])&#xD;&#xA;					&& green <= (startColor[1] + tolerance[1])&#xD;&#xA;					&& blue >= (startColor[2] - tolerance[2]) && blue <= (startColor[2] + tolerance[2]));&#xD;&#xA;		}&#xD;&#xA;	&#xD;&#xA;		// Represents a linear range to be filled and branched from.&#xD;&#xA;		protected class FloodFillRange {&#xD;&#xA;			public int startX;&#xD;&#xA;			public int endX;&#xD;&#xA;			public int Y;&#xD;&#xA;	&#xD;&#xA;			public FloodFillRange(int startX, int endX, int y) {&#xD;&#xA;				this.startX = startX;&#xD;&#xA;				this.endX = endX;&#xD;&#xA;				this.Y = y;&#xD;&#xA;			}&#xD;&#xA;		}&#xD;&#xA;	}"
