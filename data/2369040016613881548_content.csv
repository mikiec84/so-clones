"Content"
"    import android.content.Context;&#xD;&#xA;    import android.graphics.Canvas;&#xD;&#xA;    import android.graphics.drawable.BitmapDrawable;&#xD;&#xA;    import android.util.AttributeSet;&#xD;&#xA;    import android.util.Log;&#xD;&#xA;    import android.view.MotionEvent;&#xD;&#xA;    import android.view.ScaleGestureDetector;&#xD;&#xA;     import android.view.View;&#xD;&#xA;    public class MyImageView extends View {&#xD;&#xA;    private static final int INVALID_POINTER_ID = -1;&#xD;&#xA;    private Drawable mImage;&#xD;&#xA;    private float mPosX;&#xD;&#xA;    private float mPosY;&#xD;&#xA;    private float mLastTouchX;&#xD;&#xA;    private float mLastTouchY;&#xD;&#xA;    private int mActivePointerId = INVALID_POINTER_ID;&#xD;&#xA;    private ScaleGestureDetector mScaleDetector;&#xD;&#xA;    private float mScaleFactor = 1.f;&#xD;&#xA;    public MyImageView(Context context) {&#xD;&#xA;        this(context, null, 0);&#xD;&#xA;    mImage=act.getResources().getDrawable(context.getResources().getIdentifier(""""imagÂ­ename"""", """"drawable"""", """"packagename""""));&#xD;&#xA;        mImage.setBounds(0, 0, mImage.getIntrinsicWidth(), mImage.getIntrinsicHeight());&#xD;&#xA;    }&#xD;&#xA;    public MyImageView(Context context, AttributeSet attrs) {&#xD;&#xA;        this(context, attrs, 0);&#xD;&#xA;    }&#xD;&#xA;    public MyImageView(Context context, AttributeSet attrs, int defStyle) {&#xD;&#xA;        super(context, attrs, defStyle);&#xD;&#xA;        mScaleDetector = new ScaleGestureDetector(context, new ScaleListener());&#xD;&#xA;    }&#xD;&#xA;    @Override&#xD;&#xA;    public boolean onTouchEvent(MotionEvent ev) {&#xD;&#xA;        // Let the ScaleGestureDetector inspect all events.&#xD;&#xA;        mScaleDetector.onTouchEvent(ev);&#xD;&#xA;        final int action = ev.getAction();&#xD;&#xA;        switch (action & MotionEvent.ACTION_MASK) {&#xD;&#xA;        case MotionEvent.ACTION_DOWN: {&#xD;&#xA;            final float x = ev.getX();&#xD;&#xA;            final float y = ev.getY();&#xD;&#xA;            mLastTouchX = x;&#xD;&#xA;            mLastTouchY = y;&#xD;&#xA;            mActivePointerId = ev.getPointerId(0);&#xD;&#xA;            break;&#xD;&#xA;        }&#xD;&#xA;        case MotionEvent.ACTION_MOVE: {&#xD;&#xA;            final int pointerIndex = ev.findPointerIndex(mActivePointerId);&#xD;&#xA;            final float x = ev.getX(pointerIndex);&#xD;&#xA;            final float y = ev.getY(pointerIndex);&#xD;&#xA;            // Only move if the ScaleGestureDetector isn't processing a gesture.&#xD;&#xA;            if (!mScaleDetector.isInProgress()) {&#xD;&#xA;                final float dx = x - mLastTouchX;&#xD;&#xA;                final float dy = y - mLastTouchY;&#xD;&#xA;                mPosX += dx;&#xD;&#xA;                mPosY += dy;&#xD;&#xA;                invalidate();&#xD;&#xA;            }&#xD;&#xA;            mLastTouchX = x;&#xD;&#xA;            mLastTouchY = y;&#xD;&#xA;            break;&#xD;&#xA;        }&#xD;&#xA;        case MotionEvent.ACTION_UP: {&#xD;&#xA;            mActivePointerId = INVALID_POINTER_ID;&#xD;&#xA;            break;&#xD;&#xA;        }&#xD;&#xA;        case MotionEvent.ACTION_CANCEL: {&#xD;&#xA;            mActivePointerId = INVALID_POINTER_ID;&#xD;&#xA;            break;&#xD;&#xA;        }&#xD;&#xA;        case MotionEvent.ACTION_POINTER_UP: {&#xD;&#xA;            final int pointerIndex = (ev.getAction() & MotionEvent.ACTION_POINTER_INDEX_MASK) &#xD;&#xA;                    >> MotionEvent.ACTION_POINTER_INDEX_SHIFT;&#xD;&#xA;            final int pointerId = ev.getPointerId(pointerIndex);&#xD;&#xA;            if (pointerId == mActivePointerId) {&#xD;&#xA;                // This was our active pointer going up. Choose a new&#xD;&#xA;                // active pointer and adjust accordingly.&#xD;&#xA;                final int newPointerIndex = pointerIndex == 0 ? 1 : 0;&#xD;&#xA;                mLastTouchX = ev.getX(newPointerIndex);&#xD;&#xA;                mLastTouchY = ev.getY(newPointerIndex);&#xD;&#xA;                mActivePointerId = ev.getPointerId(newPointerIndex);&#xD;&#xA;            }&#xD;&#xA;            break;&#xD;&#xA;        }&#xD;&#xA;        }&#xD;&#xA;        return true;&#xD;&#xA;    }&#xD;&#xA;    @Override&#xD;&#xA;    public void onDraw(Canvas canvas) {&#xD;&#xA;        super.onDraw(canvas);&#xD;&#xA;        canvas.save();&#xD;&#xA;        Log.d(""""DEBUG"""", """"X: """"+mPosX+"""" Y: """"+mPosY);&#xD;&#xA;        canvas.translate(mPosX, mPosY);&#xD;&#xA;        canvas.scale(mScaleFactor, mScaleFactor);&#xD;&#xA;        mImage.draw(canvas);&#xD;&#xA;        canvas.restore();&#xD;&#xA;    }&#xD;&#xA;    private class ScaleListener extends ScaleGestureDetector.SimpleOnScaleGestureListener {&#xD;&#xA;        @Override&#xD;&#xA;        public boolean onScale(ScaleGestureDetector detector) {&#xD;&#xA;            mScaleFactor *= detector.getScaleFactor();&#xD;&#xA;            // Don't let the object get too small or too large.&#xD;&#xA;            mScaleFactor = Math.max(0.1f, Math.min(mScaleFactor, 10.0f));&#xD;&#xA;            invalidate();&#xD;&#xA;            return true;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    }"
