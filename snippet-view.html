<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">

    <title>SO Clones</title>

    <link rel="stylesheet" type="text/css" href="global.css"/>

    <script src="lib/d3/d3.min.js"></script>
    <script src="lib/marked/marked.min.js"></script>
</head>
<body>

<div class="header">
    <label for="hash-value">Hash Value: </label>
    <input id="hash-value"/>
    <button type="button" id="load-hash">Load</button>
    <div class="divider"></div>
    <button type="button" id="previous">< Previous</button>
    <button type="button" id="next">Next ></button>
    <div class="divider"></div>
    <div id="post-count-div" class="header-label">Number of Posts: </div>
</div>

<table cellspacing="20">
    <thead>
        <tr>
            <th>Snippet</th>
            <th>Posts (CreationDate)</th>
            <th>LinkedPosts (Count)</th>
            <th>ExternalLinks (Count)</th>
        </tr>
    </thead>
    <tbody>
    <tr>
        <td>
            <div id="markdown-content" class="markdown"></div>
            <div class="license">Snippet licensed under <a target="_blank" href="https://creativecommons.org/licenses/by-sa/3.0/legalcode">CC SY-SA 3.0</a>.</div>
        </td>
        <td>
            <div id="posts"></div>
        </td>
        <td>
            <div id="linked-posts"></div>
        </td>
        <td>
            <div id="other-links"></div>
        </td>
    </tr>
    </tbody>
</table>

<script>
    function errorMessage(errorMessage) {
        alert(errorMessage);
        throw new Error(errorMessage);
    }

    var queryParameters = [];
    var snippetMetadata;
    var posts;
    var currentIndex;
    var linkedPosts;
    var otherLinks;
    var loadHashButton = d3.select("#load-hash");
    var nextButton = d3.select("#next");
    var previousButton = d3.select("#previous");
    var hashInput = document.getElementById("hash-value");
    var markdownContent = document.getElementById("markdown-content");
    var postsDiv = d3.select("#posts");
    var linkedPostsDiv = d3.select("#linked-posts");
    var otherLinksDiv = d3.select("#other-links");
    var postCountDiv = d3.select("#post-count-div");

    // read query parameters
    window.location.search.substr(1).split("&").forEach(function(keyValueString) {
        var keyValue = keyValueString.split("=");
        queryParameters[keyValue[0]] = keyValue[1];
    });

    if (!Object.keys(queryParameters).includes("hashValue")) {
        errorMessage("Query parameter hashValue is missing.");
    }

    // set hash value
    hashInput.value = queryParameters["hashValue"];

    // register event handlers
    loadHashButton.on("click", function() {
        if (loadMetadata()) {
            updateView();
        }
    });

    nextButton.on("click", function() {
        if (currentIndex < snippetMetadata.length-1) {
            currentIndex++;
            hashInput.value = snippetMetadata[currentIndex].HashValue;
            if (loadMetadata()) {
                updateView();
            }
        }
    });

    previousButton.on("click", function() {
        if (currentIndex > 0) {
            currentIndex--;
            hashInput.value = snippetMetadata[currentIndex].HashValue;
            if (loadMetadata()) {
                updateView();
            }
        }
    });

    // read index file
    d3.csv("data/index.csv", function (row, index) {
        return {
            Index: index,
            HashValue: row.HashValue,
            ThreadCount: parseInt(row.ThreadCount),
            LineCount: parseInt(row.LineCount)
        }
    }).then(function(data) {
        snippetMetadata = data;

        if (loadMetadata()) {
            updateView();
        }
    });

    function getStackOverflowUrl(post, onlySuffix) {
        var suffix;
        if (post.PostTypeId === 1) {
            suffix = "q/" + post.PostId;
        } else if (post.PostTypeId === 2) {
            suffix = "a/" + post.PostId;
        } else {
            errorMessage("Invalid PostTypeId " + post.PostTypeId);
        }
        if (onlySuffix) {
            return suffix;
        } else {
            return "https://stackoverflow.com/" + suffix;
        }
    }

    function prepareContent(content) {
        return content
            .split("&#xD;&#xA;") // replace escaped new line characters
            .map(function(line) {
                var result = line.replace(new RegExp("\t", "g"), "");
                while (!result.startsWith("    ")) {
                    result = " " + result;
                }
                return result;
            })
            .join("\n")
            .split("\"\"") // replace escaped double quotes
            .join("\"");
    }

    function loadMetadata() {
        var row = snippetMetadata.find(function(row) { return row.HashValue === hashInput.value.trim() });

        if (row == null) {
            errorMessage("Hash value not found.");
            return false;
        }

        currentIndex = row.Index;

        // update buttons
        if (currentIndex < snippetMetadata.length-1) {
            nextButton.attr("disabled", null);
        } else {
            nextButton.attr("disabled", "disabled");
        }
        if (currentIndex > 0) {
            previousButton.attr("disabled", null);
        } else {
            previousButton.attr("disabled", "disabled");
        }

        return true;
    }

    function updateView() {
        loadSnippet();
        loadPosts();
        loadSOLinks();
        loadOtherLinks();
    }

    function loadSnippet() {
        d3.csv("data/" + hashInput.value.trim() + "_content.csv", function (row) {
            return {
                Content: prepareContent(row.Content)
            }
        }).then(function(data) {
            markdownContent.innerHTML = marked(data[0].Content);
        });
    }

    function extractDateString(date) {
        return date.toISOString().split(".000Z")[0].split("T")[0];
    }

    function loadPosts() {
        d3.csv("data/" + hashInput.value.trim() + ".csv", function (row) {
            return {
                PostId: parseInt(row.PostId),
                PostTypeId: parseInt(row.PostTypeId),
                ParentId: parseInt(row.ParentId),
                CreationDate: extractDateString(new Date(row.CreationDate))
            }
        }).then(function(data) {
            posts = data;

            postCountDiv
                .selectAll("span")
                .remove();
            postCountDiv
                .append("span")
                .text(posts.length);

            postsDiv
                .selectAll("div")
                .remove();
            postsDiv
                .selectAll("div")
                .data(posts)
                .enter()
                .append("div")
                .append("a")
                .attr("href", function(post) {
                    return getStackOverflowUrl(post);
                })
                .text(function(post) {
                    return getStackOverflowUrl(post, true);
                })
                .attr("target", "_blank");

            postsDiv
                .selectAll("span")
                .remove();
            postsDiv
                .selectAll("div")
                .data(posts)
                .append("span")
                .text(function(post) {
                    return " (" + post.CreationDate + ")"
                })
        });
    }

    function loadSOLinks() {
        d3.csv("data/" + hashInput.value.trim() + "_so-links.csv", function (row) {
            return {
                PostId: parseInt(row.LinkedPostId),
                PostTypeId: parseInt(row.LinkedPostTypeId),
                PostCount: parseInt(row.PostCount)
            }
        }).then(function(data) {
            linkedPosts = data;

            linkedPostsDiv
                .selectAll("div")
                .remove();

            linkedPostsDiv
                .selectAll("div")
                .data(linkedPosts)
                .enter()
                .append("div")
                .append("a")
                .attr("href", function(linkedPost) {
                    return getStackOverflowUrl(linkedPost);
                })
                .text(function(linkedPost) {
                    return getStackOverflowUrl(linkedPost, true);
                })
                .attr("target", "_blank");

            linkedPostsDiv
                .selectAll("div")
                .data(linkedPosts)
                .append("span")
                .text(function(linkedPost) { return " (" + linkedPost.PostCount + ")"});
        });
    }

    function truncateString(string) {
        if (string.length > 40) {
            return string.substring(0, 38) + "...";
        } else {
            return string;
        }
    }

    function loadOtherLinks() {
        d3.csv("data/" + hashInput.value.trim() + "_links.csv", function (row) {
            return {
                Url: row.Url,
                PostCount: parseInt(row.PostCount)
            }
        }).then(function(data) {
            otherLinks = data;

            otherLinksDiv
                .selectAll("div")
                .remove();

            otherLinksDiv
                .selectAll("div")
                .data(otherLinks)
                .enter()
                .append("div")
                .append("a")
                .attr("href", function(linkedUrl) {
                    return linkedUrl.Url;
                })
                .text(function(linkedUrl) {
                    return truncateString(linkedUrl.Url);
                })
                .attr("target", "_blank");

            otherLinksDiv
                .selectAll("div")
                .data(otherLinks)
                .append("span")
                .text(function(linkedUrl) { return " (" + linkedUrl.PostCount + ")" });
        });
    }

</script>

</body>
</html>